{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/core/Box.ts","webpack:///./lib/core/BoxContainer.ts","webpack:///./lib/core/BranchParentAlignment.ts","webpack:///./lib/core/Connector.ts","webpack:///./lib/core/DiagramLayoutSettings.ts","webpack:///./lib/core/Diagram.ts","webpack:///./lib/core/Dimensions.ts","webpack:///./lib/core/Edge.ts","webpack:///./lib/core/FishboneAssistantsLayoutStrategy.ts","webpack:///./lib/core/BoxTree.ts","webpack:///./lib/core/LayoutAlgorithm.ts","webpack:///./lib/core/LayoutStateOperationChangedEventArgs.ts","webpack:///./lib/core/Step.ts","webpack:///./lib/core/Boundary.ts","webpack:///./lib/core/LayoutLevel.ts","webpack:///./lib/core/BoundaryChangedEventArgs.ts","webpack:///./lib/core/LayoutState.ts","webpack:///./lib/core/LayoutStrategyBase.ts","webpack:///./lib/core/LinearLayoutStrategy.ts","webpack:///./lib/core/MultiLineFishboneLayoutStrategy.ts","webpack:///./lib/core/MultiLineHangerLayoutStrategy.ts","webpack:///./lib/core/NodeLayoutInfo.ts","webpack:///./lib/core/Node.ts","webpack:///./lib/core/Operation.ts","webpack:///./lib/core/Point.ts","webpack:///./lib/core/Rect.ts","webpack:///./lib/core/SingleColumnLayoutStrategy.ts","webpack:///./lib/core/Size.ts","webpack:///./lib/core/StackOrientation.ts","webpack:///./lib/core/StackingLayoutStrategy.ts","webpack:///./lib/core/Utils.ts","webpack:///./lib/test/Random.ts","webpack:///./lib/test/TestDataGen.ts","webpack:///./lib/test/TestDataSource.ts","webpack:///./src/demo.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Box","this","DataId","id","visualParentId","disableCollisionDetection","dataId","parentId","isSpecial","isAssistant","Error","Id","ParentId","IsSpecial","IsAssistant","DisableCollisionDetection","AssistantLayoutStrategyId","LayoutStrategyId","IsCollapsed","Size","None","BoxContainer","source","_lastBoxId","_boxesById","Map","_boxesByDataId","SystemRoot","ReloadBoxes","clear","Special","set","map","AllDataItemIds","NextBoxId","getDataItem","GetDataItemFunc","parentDataId","GetParentKeyFunc","nextBoxId","_AddBox","box","BranchParentAlignment","BranchParentAlignment2","Connector","segments","length","Segments","DiagramLayoutSettings","_branchSpacing","DefaultAssistantLayoutStrategyId","DefaultLayoutStrategyId","BranchSpacing","LayoutStrategies","result","_visualTree","_boxes","LayoutSettings","Dimensions","Number","MAX_VALUE","MIN_VALUE","from","to","From","To","x","y","Math","min","max","Edge","FishboneAssistantsLayoutStrategy","super","arguments","GetSupportsAssistants","MaxOnLeft","node","floor","State","NumberOfSiblings","NeedCarrierProtector","_a","ParentNode","ChildCount","state","NumberOfSiblingColumns","NumberOfSiblingRows","spacer","Element","AddRegularChildBox","level","BranchRoot","Level","SiblingsRowV","prevRowBottom","maxOnLeft","spacing","ParentChildSpacing","SiblingSpacing","child","Children","frame","MoveTo","Left","rowExterior","Top","Bottom","i2","child2","frame2","CenterV","Height","BranchExterior","TopLeft","add","VerticalLayout","left","countOnThisSide","HorizontalLayout","AlignHorizontalCenters","EnumerateSiblings","rightmost","k","Right","opposite","AdjustSpacer","ParentConnectorShield","Boundary","MergeFromNode","carrier","CenterH","diff","MoveChildrenOnly","count","ix","isLeft","bottomMost","nodes","push","Depth","Root","Nodes","func","IterateChildFirst","enter","exit","IterateParentFirst","IsAssistantRoot","Diagram","Boxes","BoxesById","values","Node","parentKey","parentNode","AddAssistantChild","AddRegularChild","visualTree","Rect","initialized","box2","IsHidden","_b","CurrentOperation","Operation","Preparing","tree","Build","VisualTree","UpdateHierarchyStats","AttachVisualTree","PreprocessVisualTree","BoxSizeFunc","filter","IsDataBound","AssertBoxSize","Point","ConnectorsLayout","RouteConnectors","Completed","Width","defaultStrategy","RequireDefaultLayoutStrategy","defaultAssistantsStrategy","RequireDefaultAssistantLayoutStrategy","regular","assistants","strategy","LayoutOptimizerFunc","suggestedStrategyId","SupportsAssistants","SuppressAssistants","EffectiveLayoutStrategy","RequireLayoutStrategy","PreProcessThisNode","AssistantsRoot","pop","branchRoot","PushLayoutLevel","ApplyHorizontalLayout","PopLayoutLevel","ApplyVerticalLayout","layoutLevel","offset","children","action","MoveH","e","ReloadFromBranch","BoundingRect","root","MoveOneChild","subset","center","leftmost","c2","other","EPSILON","abs","w","h","LayoutStateOperactionChangedEventArgs","Step","top","bottom","X","newTop","newBottom","newNode","newX","frompublic","_spacerMerger","_boundingRect","Prepare","rect","merge","mySteps","theirSteps","my","th","ValidateState","theirWins","LayoutAlgorithm","IsEqual","ChangeOwner","ChangeTop","splice","ChangeBottom","IsZero","PrepareForHorizontalLayout","MergeFrom","siblingSpacing","branchSpacing","offense","desiredSpacing","newLeft","ChangeX","right","newRight","LayoutLevel","boundary","BoundaryChangedEventArgs","diagram","_currentOperation","Idle","_layoutStack","_pooledBoundaries","BoundaryChanged","OperationChanged","innerLevel","higherLevel","VerticalMergeFrom","overlap","ComputeOverlap","MoveBranch","LayoutStrategyBase","ParentAlignment","InvalidValue","ChildConnectorHookLength","LinearLayoutStrategy","verticalSpacer","horizontalSpacer","CopyExteriorFrom","siblingsRowExterior","MinMax","desiredCenter","Center","MergeSpacer","firstInRow","normalChildCount","rootRect","space","childRect","childCenter","Y","GroupIterator","numberOfSiblings","numberOfGroups","Group","FromIndex","Count","_numberOfSiblings","_numberOfGroups","countInRow","countToThisGroup","countInThisRow","CountInGroup","TreeNodeView","element","capacity","SingleFishboneLayoutAdapter","realRoot","Iterator","RealRoot","SpecialRoot","parentStrategy","NextGroup","AddChildView","MultiLineFishboneLayoutStrategy","MaxGroups","parentSpacer","adapter","leftCarrier","rightCarrier","iterator","leftGroup","rightGroup","MultiLineHangerLayoutStrategy","MaxSiblingsPerRow","lastRowBoxCount","siblingSpacer","InsertRegularChildBoxByIndex","prevRowExterior","row","siblingsBottom","spacerIndex","spacerBottom","col","EnumerateColumn","firstInRowIndex","lastInRow","width","verticalCarrierHeight","lastChildHookIndex","_effectiveLayoutStrategy","InsertRegularChild","index","Operation2","offsetX","size","topLeft","SingleColumnLayoutStrategy","childBranchBottom","nodeState","edges","spacerTop","Array","destination","StackOrientation","StackOrientation2","StackingLayoutStrategy","Orientation","SingleRowHorizontal","SingleColumnVertical","peek","array","Random","seed","range","random","dataSource","percentAssistants","item","GenerateRandomDataItems","Items","itemCount","items","toString","Date1","Date","String1","String2","firstInLayer","prevLayerSize","layerSize","Next","parentIndex","temp","assistantCount","round","ceil","boxContainer","TestDataSource","itemId","GetParentKey","GetDataItem","keys","sort","ChartApp","suppressRootBox","totalBoxCount","onLayoutStateChanged","args","renderBoxes","buildChart","boxId","positionBoxes","initData","initDiagram","isCollapsed","BoxesByDataId","GenerateDataItems","delete","dataItem","$","html","generateData","checked","collapseAllBoxes","linearLayoutStrategy","multiLineHangerLayoutStrategy","singleColumnLayoutStrategy","fishboneLayoutStrategy","hstackLayoutStrategy","vstackLayoutStrategy","assistantsLayoutStrategy","elements","expanders","existing","exp","hide","show","getBoxLevel","className","1","2","3","position","document","createElement","style","height","innerText","addEventListener","boxClick","expander","getBoxElementSize","myDiagramDiv","querySelector","appendChild","selector","branchOptimizerAllLinear","childCount","nonLeafChildren","boxSizeFunc","getBranchOptimizerName","console","log","Apply","diagramBoundary","ComputeBranchVisualBoundingRect","offsetx","offsety","connectors","edgeType","edge","connector","myConnectors","window","chartApp","changedSuppressRootBox","cb","clickCollapseAll","bt","clickExpandAll","clickOptimizer","rd","clickDataCounts"],"mappings":"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","file":"demo.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/demo.ts\");\n","import Size2 from \"./Size\";\nexport default class Box {\n  get IsDataBound() {\n    return !!this.DataId;\n  }\n  static Special(id, visualParentId, disableCollisionDetection) {\n    return new Box(null, id, visualParentId, true, disableCollisionDetection, false);\n  }\n  constructor(dataId, id, parentId, isSpecial, disableCollisionDetection, isAssistant) {\n    if (id == 0) {\n      throw new Error(`Invalid ${id}`);\n    }\n    this.Id = id;\n    this.ParentId = parentId;\n    this.DataId = dataId;\n    this.IsSpecial = isSpecial;\n    this.IsAssistant = isAssistant;\n    this.DisableCollisionDetection = disableCollisionDetection;\n    this.AssistantLayoutStrategyId = null;\n    this.LayoutStrategyId = null;\n    this.IsCollapsed = false;\n    this.Size = new Size2(0, 0);\n  }\n}\nBox.None = -1;\n","import Box2 from \"./Box\";\nexport default class BoxContainer {\n  constructor(source) {\n    this._lastBoxId = 0;\n    this._boxesById = new Map();\n    this._boxesByDataId = new Map();\n    this.SystemRoot = null;\n    if (source) {\n      this.ReloadBoxes(source);\n    }\n  }\n  get BoxesById() {\n    return this._boxesById;\n  }\n  get BoxesByDataId() {\n    return this._boxesByDataId;\n  }\n  ReloadBoxes(source) {\n    this._boxesByDataId.clear();\n    this._boxesById.clear();\n    this._lastBoxId = 0;\n    this.SystemRoot = Box2.Special(++this._lastBoxId, Box2.None, true);\n    this._boxesById.set(this.SystemRoot.Id, this.SystemRoot);\n    const map = new Map();\n    for (const dataId of source.AllDataItemIds) {\n      map.set(dataId, this.NextBoxId());\n    }\n    const getDataItem = source.GetDataItemFunc;\n    for (const dataId of source.AllDataItemIds) {\n      const parentDataId = !dataId ? null : source.GetParentKeyFunc(dataId);\n      const visualParentId = !parentDataId ? this.SystemRoot.Id : map.get(parentDataId);\n      const nextBoxId = map.get(dataId);\n      if (nextBoxId != null && visualParentId != null) {\n        this._AddBox(dataId, nextBoxId, visualParentId, getDataItem(dataId).IsAssistant);\n      } else {\n      }\n    }\n  }\n  AddBox(dataId, visualParentId, isAssistant) {\n    return this._AddBox(dataId, this.NextBoxId(), visualParentId, isAssistant);\n  }\n  _AddBox(dataId, id, visualParentId, isAssistant) {\n    const box = new Box2(dataId, id, visualParentId, false, false, isAssistant);\n    this._boxesById.set(box.Id, box);\n    if (box.DataId) {\n      this._boxesByDataId.set(box.DataId, box);\n    }\n    return box;\n  }\n  NextBoxId() {\n    this._lastBoxId++;\n    return this._lastBoxId;\n  }\n}\n","var BranchParentAlignment;\n(function(BranchParentAlignment2) {\n  BranchParentAlignment2[BranchParentAlignment2[\"InvalidValue\"] = 0] = \"InvalidValue\";\n  BranchParentAlignment2[BranchParentAlignment2[\"Left\"] = 1] = \"Left\";\n  BranchParentAlignment2[BranchParentAlignment2[\"Center\"] = 2] = \"Center\";\n  BranchParentAlignment2[BranchParentAlignment2[\"Right\"] = 3] = \"Right\";\n})(BranchParentAlignment || (BranchParentAlignment = {}));\nexport default BranchParentAlignment;\n","export default class Connector {\n  constructor(segments) {\n    if (segments.length == 0) {\n      throw new Error(\"Need at least one segment\");\n    }\n    this.Segments = segments;\n  }\n}\n","export default class DiagramLayoutSettings {\n  constructor() {\n    this._branchSpacing = 0;\n    this.DefaultAssistantLayoutStrategyId = null;\n    this.DefaultLayoutStrategyId = null;\n    this.BranchSpacing = 50;\n    this.LayoutStrategies = new Map();\n  }\n  get BranchSpacing() {\n    return this._branchSpacing;\n  }\n  set BranchSpacing(value) {\n    if (value < 0) {\n      throw new Error(\"Cannot be negative\");\n    }\n    this._branchSpacing = value;\n  }\n  RequireDefaultLayoutStrategy() {\n    const id = this.DefaultLayoutStrategyId;\n    if (!id) {\n      throw new Error(\"DefaultLayoutStrategyId is null or not valid\");\n    }\n    const result = this.LayoutStrategies.get(id);\n    if (!result) {\n      throw new Error(\"DefaultLayoutStrategyId is null or not valid\");\n    }\n    return result;\n  }\n  RequireDefaultAssistantLayoutStrategy() {\n    {\n      const id = this.DefaultAssistantLayoutStrategyId;\n      if (!id) {\n        throw new Error(\"DefaultLayoutStrategyId is null or not valid\");\n      }\n      const result = this.LayoutStrategies.get(id);\n      if (!result) {\n        throw new Error(\"DefaultLayoutStrategyId is null or not valid\");\n      }\n      return result;\n    }\n  }\n}\n","import DiagramLayoutSettings2 from \"./DiagramLayoutSettings\";\nexport default class Diagram {\n  constructor() {\n    this._visualTree = null;\n    this._boxes = null;\n    this.LayoutSettings = new DiagramLayoutSettings2();\n  }\n  get Boxes() {\n    if (this._boxes == null) {\n      throw Error(\"Boxes is null\");\n    }\n    return this._boxes;\n  }\n  set Boxes(value) {\n    this._visualTree = null;\n    this._boxes = value;\n  }\n  get VisualTree() {\n    return this._visualTree;\n  }\n  set VisualTree(value) {\n    this._visualTree = value;\n  }\n}\n","export default class Dimensions {\n  static MinMax() {\n    return new Dimensions(Number.MAX_VALUE, Number.MIN_VALUE);\n  }\n  constructor(from, to) {\n    this.From = from;\n    this.To = to;\n  }\n  static add(x, y) {\n    return new Dimensions(Math.min(x.From, y.From), Math.max(x.To, y.To));\n  }\n}\n","export default class Edge {\n  constructor(from, to) {\n    this.From = from;\n    this.To = to;\n  }\n}\n","import LayoutStrategyBase2 from \"./LayoutStrategyBase\";\nimport Box2 from \"./Box\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport Rect2 from \"./Rect\";\nimport Edge2 from \"./Edge\";\nimport Point2 from \"./Point\";\nimport Connector2 from \"./Connector\";\nexport default class FishboneAssistantsLayoutStrategy extends LayoutStrategyBase2 {\n  constructor() {\n    super(...arguments);\n    this.GetSupportsAssistants = () => false;\n    this.MaxOnLeft = (node) => Math.floor(node.State.NumberOfSiblings / 2) + node.State.NumberOfSiblings % 2;\n    this.NeedCarrierProtector = (node) => {\n      var _a;\n      return ((_a = node.ParentNode) == null ? void 0 : _a.ChildCount) == 0;\n    };\n  }\n  PreProcessThisNode(state, node) {\n    node.State.NumberOfSiblings = node.ChildCount;\n    if (node.State.NumberOfSiblings > 0) {\n      node.State.NumberOfSiblingColumns = 1;\n      node.State.NumberOfSiblingRows = Math.floor(node.State.NumberOfSiblings / 2);\n      if (node.State.NumberOfSiblings % 2 != 0) {\n        node.State.NumberOfSiblingRows++;\n      }\n      var spacer = Box2.Special(Box2.None, node.Element.Id, false);\n      node.AddRegularChildBox(spacer);\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    const node = level.BranchRoot;\n    if (node.Level == 0) {\n      throw new Error(\"Should never be invoked on root node\");\n    }\n    if (node.State.SiblingsRowV == null) {\n      throw Error(\"SiblingsRowV is null\");\n    }\n    let prevRowBottom = node.State.SiblingsRowV.To;\n    const maxOnLeft = this.MaxOnLeft(node);\n    for (var i = 0; i < maxOnLeft; i++) {\n      const spacing = i == 0 ? this.ParentChildSpacing : this.SiblingSpacing;\n      const child = node.Children[i];\n      const frame = child.State;\n      LayoutAlgorithm2.MoveTo(frame, frame.Left, prevRowBottom + spacing);\n      let rowExterior = new Dimensions2(frame.Top, frame.Bottom);\n      const i2 = i + maxOnLeft;\n      if (frame.Size == null) {\n        throw Error(\"Size is null\");\n      }\n      if (i2 < node.State.NumberOfSiblings) {\n        const child2 = node.Children[i2];\n        const frame2 = child2.State;\n        LayoutAlgorithm2.MoveTo(frame2, frame2.Left, prevRowBottom + spacing);\n        if (frame2.Size == null) {\n          throw Error(\"Size is null\");\n        }\n        if (frame2.Bottom > frame.Bottom) {\n          LayoutAlgorithm2.MoveTo(frame, frame.Left, frame2.CenterV - frame.Size.Height / 2);\n        } else if (frame2.Bottom < frame.Bottom) {\n          LayoutAlgorithm2.MoveTo(frame2, frame2.Left, frame.CenterV - frame2.Size.Height / 2);\n        }\n        frame2.BranchExterior = Rect2.from(frame2.Size, frame2.TopLeft);\n        rowExterior = Dimensions2.add(rowExterior, new Dimensions2(frame2.Top, frame2.Bottom));\n        frame2.SiblingsRowV = rowExterior;\n        LayoutAlgorithm2.VerticalLayout(state, child2);\n        prevRowBottom = frame2.BranchExterior.Bottom;\n      }\n      frame.BranchExterior = Rect2.from(frame.Size, frame.TopLeft);\n      frame.SiblingsRowV = rowExterior;\n      LayoutAlgorithm2.VerticalLayout(state, child);\n      prevRowBottom = Math.max(prevRowBottom, frame.BranchExterior.Bottom);\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    var node = level.BranchRoot;\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    var left = true;\n    var countOnThisSide = 0;\n    var maxOnLeft = this.MaxOnLeft(node);\n    for (var i = 0; i < node.State.NumberOfSiblings; i++) {\n      var child = node.Children[i];\n      LayoutAlgorithm2.HorizontalLayout(state, child);\n      if (++countOnThisSide == maxOnLeft) {\n        if (left) {\n          LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateSiblings(node, 0, maxOnLeft));\n          left = false;\n          countOnThisSide = 0;\n          var rightmost = Number.MIN_VALUE;\n          for (var k = 0; k <= i; k++) {\n            rightmost = Math.max(rightmost, node.Children[k].State.BranchExterior.Right);\n          }\n          if (node.State.NumberOfSiblings % 2 != 0) {\n            rightmost = Math.max(rightmost, child.State.Right);\n          } else {\n            var opposite = node.Children[node.State.NumberOfSiblings - 1];\n            if (opposite.Element.IsCollapsed || opposite.ChildCount == 0) {\n              rightmost = Math.max(rightmost, child.State.Right);\n            } else {\n              rightmost = Math.max(rightmost, child.State.BranchExterior.Right);\n            }\n          }\n          const spacer = node.Children[node.State.NumberOfSiblings];\n          LayoutAlgorithm2.AdjustSpacer(spacer.State, rightmost, node.State.Bottom, this.ParentConnectorShield, node.State.BranchExterior.Bottom - node.State.Bottom);\n          level.Boundary.MergeFromNode(spacer);\n        }\n      }\n    }\n    LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateSiblings(node, maxOnLeft, node.State.NumberOfSiblings));\n    if (node.Level > 0 && node.State.NumberOfSiblings > 0) {\n      let carrier = node.Children[node.State.NumberOfSiblings].State.CenterH;\n      let desiredCenter = node.State.CenterH;\n      const diff = desiredCenter - carrier;\n      LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n    }\n  }\n  RouteConnectors(state, node) {\n    var count = node.State.NumberOfSiblings;\n    if (count == 0) {\n      return;\n    }\n    if (this.NeedCarrierProtector(node)) {\n      count++;\n    }\n    var segments = [];\n    var ix = 0;\n    var maxOnLeft = this.MaxOnLeft(node);\n    var carrier = node.Children[node.State.NumberOfSiblings].State;\n    var from = carrier.CenterH;\n    var isLeft = true;\n    var countOnThisSide = 0;\n    var bottomMost = Number.MIN_VALUE;\n    for (var i = 0; i < node.State.NumberOfSiblings; i++) {\n      var to = isLeft ? node.Children[i].State.Right : node.Children[i].State.Left;\n      var y = node.Children[i].State.CenterV;\n      bottomMost = Math.max(bottomMost, y);\n      segments[ix++] = new Edge2(new Point2(from, y), new Point2(to, y));\n      if (++countOnThisSide == maxOnLeft) {\n        countOnThisSide = 0;\n        isLeft = !isLeft;\n      }\n    }\n    if (this.NeedCarrierProtector(node)) {\n      segments[node.State.NumberOfSiblings] = new Edge2(new Point2(carrier.CenterH, carrier.Top), new Point2(carrier.CenterH, bottomMost));\n    }\n    node.State.Connector = new Connector2(segments);\n  }\n  EnumerateSiblings(node, from, to) {\n    const nodes = [];\n    for (var i = from; i < to; i++) {\n      nodes.push(node.Children[i]);\n    }\n    return nodes;\n  }\n}\n","import Box2 from \"./Box\";\nimport Node2 from \"./Node\";\nexport default class BoxTree {\n  constructor() {\n    this.Depth = 0;\n    this.Root = null;\n    this.Nodes = new Map();\n  }\n  IterateChildFirst(func) {\n    if (this.Root == null) {\n      throw Error(\"Root is null\");\n    }\n    return this.Root.IterateChildFirst(func);\n  }\n  IterateParentFirst(enter, exit) {\n    if (this.Root == null) {\n      throw Error(\"Root is null\");\n    }\n    this.Root.IterateParentFirst(enter, exit);\n  }\n  UpdateHierarchyStats() {\n    this.Depth = 0;\n    this.IterateParentFirst((x) => {\n      if (x.ParentNode != null) {\n        x.Level = x.ParentNode.Level;\n        if (!x.ParentNode.IsAssistantRoot) {\n          x.Level = x.Level + 1;\n        }\n        this.Depth = Math.max(1 + x.Level, this.Depth);\n      } else {\n        x.Level = 0;\n        this.Depth = 1;\n      }\n      return true;\n    });\n  }\n  static Build(state) {\n    const result = new BoxTree();\n    let box;\n    for (box of state.Diagram.Boxes.BoxesById.values()) {\n      const node = new Node2(box);\n      result.Nodes.set(box.Id, node);\n    }\n    for (const node of result.Nodes.values()) {\n      const parentKey = node.Element.ParentId;\n      const parentNode = result.Nodes.get(parentKey);\n      if (parentNode) {\n        if (node.Element.IsAssistant && parentNode.Element.ParentId != Box2.None) {\n          parentNode.AddAssistantChild(node);\n        } else {\n          parentNode.AddRegularChild(node);\n        }\n      } else {\n        if (result.Root != null) {\n          throw new Error(\"InvalidOperationException: More then one root found: \" + node.Element.Id);\n        }\n        result.Root = node;\n      }\n    }\n    return result;\n  }\n}\n","import Rect2 from \"./Rect\";\nimport BoxTree2 from \"./BoxTree\";\nimport Operation2 from \"./Operation\";\nimport Point2 from \"./Point\";\nimport Dimensions2 from \"./Dimensions\";\nimport Size2 from \"./Size\";\nimport {peek} from \"./Utils\";\nexport default class LayoutAlgorithm {\n  static ComputeBranchVisualBoundingRect(visualTree) {\n    let result = new Rect2(0, 0, 0, 0);\n    let initialized = false;\n    if (visualTree.Root == null) {\n      throw Error(\"Root is null\");\n    }\n    visualTree.Root.IterateParentFirst((node) => {\n      var box2 = node.Element;\n      if (!node.State.IsHidden && !box2.IsSpecial) {\n        if (node.State.Size == null) {\n          throw Error(\"Size is null\");\n        }\n        if (node.State.TopLeft == null) {\n          throw Error(\"TopLeft is null\");\n        }\n        if (initialized) {\n          result = Rect2.add(result, Rect2.from(node.State.Size, node.State.TopLeft));\n        } else {\n          initialized = true;\n          result = Rect2.from(node.State.Size, node.State.TopLeft);\n        }\n      }\n      return !box2.IsCollapsed;\n    });\n    return result;\n  }\n  static Apply(state) {\n    var _a, _b;\n    if (state.Diagram.Boxes && state.Diagram.Boxes.SystemRoot == null) {\n      throw new Error(\"SystemRoot is not initialized on the box container\");\n    }\n    state.CurrentOperation = Operation2.Preparing;\n    var tree = BoxTree2.Build(state);\n    state.Diagram.VisualTree = tree;\n    if (tree.Root == null || state.Diagram.Boxes && tree.Root.Element.Id != ((_a = state.Diagram.Boxes.SystemRoot) == null ? void 0 : _a.Id)) {\n      throw new Error(\"SystemRoot is not on the top of the visual tree\");\n    }\n    tree.UpdateHierarchyStats();\n    state.AttachVisualTree(tree);\n    tree.IterateParentFirst((node) => {\n      node.State.IsHidden = node.ParentNode != null && (node.ParentNode.State.IsHidden || node.ParentNode.Element.IsCollapsed);\n      return true;\n    });\n    state.CurrentOperation = Operation2.PreprocessVisualTree;\n    if (state.BoxSizeFunc != null) {\n      for (const box2 of [...(_b = state.Diagram.Boxes) == null ? void 0 : _b.BoxesById.values()].filter((x) => x.IsDataBound)) {\n        box2.Size = state.BoxSizeFunc(box2.DataId);\n      }\n    }\n    for (const box2 of state.Diagram.Boxes.BoxesById.values()) {\n      this.AssertBoxSize(box2);\n    }\n    tree.IterateParentFirst((node) => {\n      LayoutAlgorithm.MoveTo(node.State, 0, 0);\n      node.State.Size = node.Element.Size;\n      node.State.BranchExterior = Rect2.from(node.Element.Size, new Point2(0, 0));\n      return true;\n    });\n    this.PreprocessVisualTree(state, tree);\n    tree.UpdateHierarchyStats();\n    state.CurrentOperation = Operation2.VerticalLayout;\n    this.VerticalLayout(state, tree.Root);\n    state.CurrentOperation = Operation2.HorizontalLayout;\n    this.HorizontalLayout(state, tree.Root);\n    state.CurrentOperation = Operation2.ConnectorsLayout;\n    this.RouteConnectors(state, tree);\n    state.CurrentOperation = Operation2.Completed;\n  }\n  static AssertBoxSize(box2) {\n    if (box2.Size.Width >= 0 && box2.Size.Width <= 1e9) {\n      if (box2.Size.Height >= 0 && box2.Size.Width <= 1e9) {\n        return;\n      }\n    }\n    throw new Error(`Box ${box2.Id} has invalid size: ${box2.Size.Width}x${box2.Size.Height}`);\n  }\n  static PreprocessVisualTree(state, visualTree) {\n    const defaultStrategy = state.Diagram.LayoutSettings.RequireDefaultLayoutStrategy();\n    const defaultAssistantsStrategy = state.Diagram.LayoutSettings.RequireDefaultAssistantLayoutStrategy();\n    const regular = [];\n    regular.push(defaultStrategy);\n    const assistants = [];\n    assistants.push(defaultAssistantsStrategy);\n    visualTree.IterateParentFirst((node) => {\n      var _a;\n      if (node.State.IsHidden) {\n        return false;\n      }\n      let strategy = null;\n      if (state.LayoutOptimizerFunc != null) {\n        var suggestedStrategyId = state.LayoutOptimizerFunc(node);\n        if (suggestedStrategyId) {\n          strategy = state.Diagram.LayoutSettings.LayoutStrategies.get(suggestedStrategyId);\n          if (process.env.NODE_ENV !== \"production\") {\n            if (!strategy) {\n              console.info(\"Invalid strategy:\", {\n                suggestedStrategyId,\n                strategy\n              });\n            }\n          }\n        }\n      }\n      if (node.IsAssistantRoot) {\n        if (strategy == null) {\n          strategy = ((_a = node.ParentNode) == null ? void 0 : _a.Element.AssistantLayoutStrategyId) != null ? state.Diagram.LayoutSettings.LayoutStrategies.get(node.ParentNode.Element.AssistantLayoutStrategyId) : peek(assistants);\n        }\n        if (strategy == null) {\n          throw Error(\"Strategy is null. Maybe it allows null?\");\n        }\n        assistants.push(strategy);\n      } else {\n        if (strategy == null) {\n          strategy = node.Element.LayoutStrategyId != null ? state.Diagram.LayoutSettings.LayoutStrategies.get(node.Element.LayoutStrategyId) : peek(regular);\n        }\n        if (strategy == null) {\n          throw Error(\"Strategy is null. Maybe it allows null?\");\n        }\n        regular.push(strategy);\n        if (!strategy.SupportsAssistants) {\n          node.SuppressAssistants();\n        }\n      }\n      node.State.EffectiveLayoutStrategy = strategy;\n      node.State.RequireLayoutStrategy.PreProcessThisNode(state, node);\n      return !node.Element.IsCollapsed && node.ChildCount > 0 || node.AssistantsRoot != null;\n    }, (node) => {\n      if (!node.State.IsHidden) {\n        if (node.IsAssistantRoot) {\n          assistants.pop();\n        } else {\n          regular.pop();\n        }\n      }\n    });\n  }\n  static HorizontalLayout(state, branchRoot) {\n    if (branchRoot.State.IsHidden) {\n      throw new Error(`Branch root ${branchRoot.Element.Id} does not affect layout`);\n    }\n    let level = state.PushLayoutLevel(branchRoot);\n    try {\n      if (branchRoot.Level == 0 || (branchRoot.State.NumberOfSiblings > 0 || branchRoot.AssistantsRoot != null) && !branchRoot.Element.IsCollapsed) {\n        branchRoot.State.RequireLayoutStrategy.ApplyHorizontalLayout(state, level);\n      }\n    } finally {\n      state.PopLayoutLevel();\n    }\n  }\n  static VerticalLayout(state, branchRoot) {\n    if (branchRoot.State.IsHidden) {\n      throw new Error(`Branch root ${branchRoot.Element.Id} does not affect layout`);\n    }\n    var level = state.PushLayoutLevel(branchRoot);\n    try {\n      if (branchRoot.Level == 0 || (branchRoot.State.NumberOfSiblings > 0 || branchRoot.AssistantsRoot != null) && !branchRoot.Element.IsCollapsed) {\n        branchRoot.State.RequireLayoutStrategy.ApplyVerticalLayout(state, level);\n      }\n    } finally {\n      state.PopLayoutLevel();\n    }\n  }\n  static RouteConnectors(state, visualTree) {\n    visualTree.IterateParentFirst((node) => {\n      if (node.Element.IsCollapsed || node.State.NumberOfSiblings == 0 && node.AssistantsRoot == null) {\n        return false;\n      }\n      if (node.Level == 0) {\n        return true;\n      }\n      if (!node.Element.IsSpecial || node.IsAssistantRoot) {\n        node.State.RequireLayoutStrategy.RouteConnectors(state, node);\n        return true;\n      }\n      return false;\n    });\n  }\n  static MoveChildrenOnly(state, layoutLevel, offset) {\n    const children = layoutLevel.BranchRoot.Children;\n    if (children == null || children.length == 0) {\n      throw new Error(\"Should never be invoked when children not set\");\n    }\n    const action = (node) => {\n      if (!node.State.IsHidden) {\n        try {\n          node.State.TopLeft = node.State.TopLeft.MoveH(offset);\n          node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);\n        } catch (e) {\n        }\n      }\n      return true;\n    };\n    for (const child of children) {\n      child.IterateChildFirst(action);\n    }\n    layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);\n    layoutLevel.BranchRoot.State.BranchExterior = layoutLevel.Boundary.BoundingRect;\n  }\n  static MoveOneChild(state, root, offset) {\n    root.IterateChildFirst((node) => {\n      if (!node.State.IsHidden) {\n        node.State.TopLeft = node.State.TopLeft.MoveH(offset);\n        node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);\n      }\n      return true;\n    });\n  }\n  static MoveBranch(state, layoutLevel, offset) {\n    this.MoveOneChild(state, layoutLevel.BranchRoot, offset);\n    layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);\n    layoutLevel.BranchRoot.State.BranchExterior = layoutLevel.Boundary.BoundingRect;\n  }\n  static AlignHorizontalCenters(state, level, subset) {\n    let center = Number.MIN_VALUE;\n    for (const child of subset) {\n      var c = child.State.CenterH;\n      if (c > center) {\n        center = c;\n      }\n    }\n    let leftmost = Number.MAX_VALUE;\n    let rightmost = Number.MIN_VALUE;\n    for (const child of subset) {\n      const frame = child.State;\n      const c2 = frame.CenterH;\n      if (c2 !== center) {\n        const diff = center - c2;\n        this.MoveOneChild(state, child, diff);\n      }\n      leftmost = Math.min(leftmost, child.State.BranchExterior.Left);\n      rightmost = Math.max(rightmost, child.State.BranchExterior.Right);\n    }\n    level.Boundary.ReloadFromBranch(level.BranchRoot);\n    return new Dimensions2(leftmost, rightmost);\n  }\n  static CopyExteriorFrom(state, other) {\n    state.TopLeft = other.TopLeft;\n    state.Size = other.Size;\n    state.BranchExterior = other.BranchExterior;\n    state.SiblingsRowV = other.SiblingsRowV;\n  }\n  static IsMinValue(value) {\n    return value <= Number.MIN_VALUE + Number.EPSILON;\n  }\n  static IsMaxValue(value) {\n    return value >= Number.MAX_VALUE - Number.EPSILON;\n  }\n  static IsZero(value) {\n    return value <= Number.EPSILON && value >= -Number.EPSILON;\n  }\n  static IsEqual(value, other) {\n    return Math.abs(value - other) <= Number.EPSILON;\n  }\n  static MoveTo(state, x, y) {\n    state.TopLeft = new Point2(x, y);\n  }\n  static AdjustSpacer(state, x, y, w, h) {\n    state.TopLeft = new Point2(x, y);\n    state.Size = new Size2(w, h);\n    state.BranchExterior = new Rect2(x, y, w, h);\n  }\n}\n","export default class LayoutStateOperactionChangedEventArgs {\n  constructor(state) {\n    this.State = state;\n    this.CurrentOperation = state.CurrentOperation;\n  }\n}\n","export default class Step {\n  constructor(node, x, top, bottom) {\n    this.Node = node;\n    this.X = x;\n    this.Top = top;\n    this.Bottom = bottom;\n  }\n  ChangeTop(newTop) {\n    return new Step(this.Node, this.X, newTop, this.Bottom);\n  }\n  ChangeBottom(newBottom) {\n    return new Step(this.Node, this.X, this.Top, newBottom);\n  }\n  ChangeOwner(newNode, newX) {\n    return new Step(newNode, newX, this.Top, this.Bottom);\n  }\n  ChangeX(newX) {\n    return new Step(this.Node, newX, this.Top, this.Bottom);\n  }\n}\n","import Step2 from \"./Step\";\nimport Rect2 from \"./Rect\";\nimport Size2 from \"./Size\";\nimport Point2 from \"./Point\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nexport default class Boundary {\n  constructor(frompublic = true) {\n    this._spacerMerger = null;\n    this._boundingRect = null;\n    this.Left = [];\n    this.Right = [];\n    if (frompublic) {\n      this._spacerMerger = new Boundary(false);\n    }\n  }\n  get BoundingRect() {\n    if (this._boundingRect == null) {\n      throw Error(\"BoundingRect is null\");\n    }\n    return this._boundingRect;\n  }\n  set BoundingRect(value) {\n    this._boundingRect = value;\n  }\n  PrepareForHorizontalLayout(node) {\n    this.Prepare(node);\n    if (node.Element.DisableCollisionDetection) {\n      return;\n    }\n    var rect = node.State;\n    this.Left.push(new Step2(node, rect.Left, rect.Top, rect.Bottom));\n    this.Right.push(new Step2(node, rect.Right, rect.Top, rect.Bottom));\n  }\n  Prepare(node) {\n    this.Left.length = 0;\n    this.Right.length = 0;\n    this.BoundingRect = Rect2.from(node.State.Size, node.State.TopLeft);\n  }\n  VerticalMergeFrom(other) {\n    this.BoundingRect = Rect2.add(this.BoundingRect, other.BoundingRect);\n  }\n  MergeFrom(other) {\n    if (other.BoundingRect.Top >= other.BoundingRect.Bottom) {\n      throw new Error(\"Cannot merge boundary of height \" + (other.BoundingRect.Bottom - other.BoundingRect.Top));\n    }\n    let merge = \"r\";\n    while (merge != \"\\0\") {\n      let mySteps = merge == \"r\" ? this.Right : this.Left;\n      let theirSteps = merge == \"r\" ? other.Right : other.Left;\n      let i = 0;\n      let k = 0;\n      for (; k < theirSteps.length && i < mySteps.length; ) {\n        let my = mySteps[i];\n        let th = theirSteps[k];\n        if (my.Bottom <= th.Top) {\n          i++;\n          continue;\n        }\n        if (th.Bottom <= my.Top) {\n          mySteps[i] = th;\n          k++;\n          this.ValidateState();\n          continue;\n        }\n        var theirWins = merge == \"r\" ? my.X <= th.X : my.X >= th.X;\n        if (LayoutAlgorithm2.IsEqual(my.Top, th.Top)) {\n          if (LayoutAlgorithm2.IsEqual(my.Bottom, th.Bottom)) {\n            if (theirWins) {\n              mySteps[i] = th;\n            }\n            i++;\n            k++;\n            this.ValidateState();\n          } else if (my.Bottom < th.Bottom) {\n            if (theirWins) {\n              mySteps[i] = my.ChangeOwner(th.Node, th.X);\n            }\n            theirSteps[k] = th.ChangeTop(my.Bottom);\n            i++;\n            this.ValidateState();\n          } else {\n            if (theirWins) {\n              mySteps[i] = my.ChangeTop(th.Bottom);\n              mySteps.splice(i, 0, th);\n              i++;\n            }\n            k++;\n            this.ValidateState();\n          }\n        } else if (LayoutAlgorithm2.IsEqual(my.Bottom, th.Bottom)) {\n          if (my.Top < th.Top) {\n            if (theirWins) {\n              mySteps[i] = my.ChangeBottom(th.Top);\n              mySteps.splice(i + 1, 0, th);\n              i++;\n            }\n            i++;\n            k++;\n            this.ValidateState();\n          } else {\n            if (theirWins) {\n              mySteps[i] = th;\n            } else {\n              mySteps.splice(i, 0, th.ChangeBottom(my.Top));\n              i++;\n            }\n            i++;\n            k++;\n            this.ValidateState();\n          }\n        } else if (my.Top < th.Top && my.Bottom < th.Bottom) {\n          if (theirWins) {\n            mySteps[i] = my.ChangeBottom(th.Top);\n            mySteps.splice(i + 1, 0, new Step2(th.Node, th.X, th.Top, my.Bottom));\n            i++;\n          }\n          theirSteps[k] = th.ChangeTop(my.Bottom);\n          i++;\n          this.ValidateState();\n        } else if (my.Top < th.Top && my.Bottom > th.Bottom) {\n          if (theirWins) {\n            mySteps[i] = my.ChangeBottom(th.Top);\n            mySteps.splice(i + 1, 0, th);\n            mySteps.splice(i + 2, 0, my.ChangeTop(th.Bottom));\n            i += 2;\n          }\n          k++;\n          this.ValidateState();\n        } else if (my.Bottom > th.Bottom) {\n          if (theirWins) {\n            mySteps[i] = my.ChangeTop(th.Bottom);\n            mySteps.splice(i, 0, th);\n          } else {\n            mySteps.splice(i, 0, th.ChangeBottom(my.Top));\n          }\n          i++;\n          k++;\n          this.ValidateState();\n        } else {\n          if (theirWins) {\n            mySteps[i] = th.ChangeBottom(my.Bottom);\n          } else {\n            mySteps.splice(i, 0, th.ChangeBottom(my.Top));\n            i++;\n          }\n          theirSteps[k] = th.ChangeTop(my.Bottom);\n          i++;\n          this.ValidateState();\n        }\n      }\n      if (i == mySteps.length) {\n        while (k < theirSteps.length) {\n          mySteps.push(theirSteps[k]);\n          k++;\n          this.ValidateState();\n        }\n      }\n      merge = merge == \"r\" ? \"l\" : \"\\0\";\n    }\n    this.BoundingRect = Rect2.add(this.BoundingRect, other.BoundingRect);\n  }\n  ValidateState() {\n    for (var i = 1; i < this.Left.length; i++) {\n      if (this.Left[i].Top == this.Left[i].Bottom || this.Left[i].Top < this.Left[i - 1].Bottom || this.Left[i].Top <= this.Left[i - 1].Top || this.Left[i].Bottom <= this.Left[i].Top || this.Left[i].Bottom <= this.Left[i - 1].Bottom) {\n        throw new Error(\"State error at Left index \" + i);\n      }\n    }\n    for (var i = 1; i < this.Right.length; i++) {\n      if (this.Right[i].Top == this.Right[i].Bottom || this.Right[i].Top < this.Right[i - 1].Bottom || this.Right[i].Top <= this.Right[i - 1].Top || this.Right[i].Bottom <= this.Right[i].Top || this.Right[i].Bottom <= this.Right[i - 1].Bottom) {\n        throw new Error(\"State error at Right index \" + i);\n      }\n    }\n  }\n  MergeFromNode(node) {\n    if (node.Element.DisableCollisionDetection) {\n      return;\n    }\n    if (!node.State.Size || LayoutAlgorithm2.IsZero(node.State.Size.Height)) {\n      return;\n    }\n    if (this._spacerMerger == null) {\n      throw Error(\"SpaceMerger is null\");\n    }\n    this._spacerMerger.PrepareForHorizontalLayout(node);\n    this.MergeFrom(this._spacerMerger);\n  }\n  ComputeOverlap(other, siblingSpacing, branchSpacing) {\n    let i = 0, k = 0;\n    let offense = 0;\n    while (i < this.Right.length && k < other.Left.length) {\n      let my = this.Right[i];\n      let th = other.Left[k];\n      if (my.Bottom <= th.Top) {\n        i++;\n      } else if (th.Bottom <= my.Top) {\n        k++;\n      } else {\n        if (!my.Node.Element.DisableCollisionDetection && !th.Node.Element.DisableCollisionDetection) {\n          var desiredSpacing = my.Node.Element.IsSpecial || th.Node.Element.IsSpecial ? 0 : my.Node.Element.ParentId == th.Node.Element.ParentId ? siblingSpacing : branchSpacing;\n          var diff = my.X + desiredSpacing - th.X;\n          if (diff > offense) {\n            offense = diff;\n          }\n        }\n        if (my.Bottom >= th.Bottom) {\n          k++;\n        }\n        if (th.Bottom >= my.Bottom) {\n          i++;\n        }\n      }\n    }\n    return offense;\n  }\n  ReloadFromBranch(branchRoot) {\n    var leftmost = Number.MAX_VALUE;\n    var rightmost = Number.MIN_VALUE;\n    for (var i = 0; i < this.Left.length; i++) {\n      var left = this.Left[i];\n      var newLeft = left.Node.State.Left;\n      this.Left[i] = left.ChangeX(newLeft);\n      leftmost = Math.min(leftmost, newLeft);\n    }\n    for (var i = 0; i < this.Right.length; i++) {\n      var right = this.Right[i];\n      var newRight = right.Node.State.Right;\n      this.Right[i] = right.ChangeX(newRight);\n      rightmost = Math.max(rightmost, newRight);\n    }\n    leftmost = Math.min(branchRoot.State.Left, leftmost);\n    rightmost = Math.max(branchRoot.State.Right, rightmost);\n    this.BoundingRect = Rect2.from(new Size2(rightmost - leftmost, this.BoundingRect.Size.Height), new Point2(leftmost, this.BoundingRect.Top));\n  }\n}\n","export default class LayoutLevel {\n  constructor(node, boundary) {\n    this.BranchRoot = node;\n    this.Boundary = boundary;\n  }\n}\n","export default class BoundaryChangedEventArgs {\n  constructor(boundary, layoutLevel, state) {\n    this.Boundary = boundary;\n    this.LayoutLevel = layoutLevel;\n    this.State = state;\n  }\n}\n","import Operation2 from \"./Operation\";\nimport LayoutStateOperationChangedEventArgs2 from \"./LayoutStateOperationChangedEventArgs\";\nimport Boundary2 from \"./Boundary\";\nimport LayoutLevel2 from \"./LayoutLevel\";\nimport BoundaryChangedEventArgs2 from \"./BoundaryChangedEventArgs\";\nimport Rect2 from \"./Rect\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport {peek} from \"./Utils\";\nexport default class LayoutState {\n  constructor(diagram) {\n    this._currentOperation = Operation2.Idle;\n    this._layoutStack = [];\n    this._pooledBoundaries = [];\n    this.BoxSizeFunc = null;\n    this.LayoutOptimizerFunc = null;\n    this.BoundaryChanged = null;\n    this.OperationChanged = null;\n    this.Diagram = diagram;\n  }\n  get CurrentOperation() {\n    return this._currentOperation;\n  }\n  set CurrentOperation(value) {\n    this._currentOperation = value;\n    if (this.OperationChanged) {\n      this.OperationChanged(this, new LayoutStateOperationChangedEventArgs2(this));\n    }\n  }\n  AttachVisualTree(tree) {\n    while (this._pooledBoundaries.length < tree.Depth) {\n      this._pooledBoundaries.push(new Boundary2());\n    }\n  }\n  PushLayoutLevel(node) {\n    if (this._pooledBoundaries.length == 0) {\n      this._pooledBoundaries.push(new Boundary2());\n    }\n    const boundary = this._pooledBoundaries.pop();\n    switch (this.CurrentOperation) {\n      case Operation2.VerticalLayout:\n        boundary == null ? void 0 : boundary.Prepare(node);\n        break;\n      case Operation2.HorizontalLayout:\n        boundary == null ? void 0 : boundary.PrepareForHorizontalLayout(node);\n        break;\n      default:\n        throw new Error(\"This operation can only be invoked when performing vertical or horizontal layouts\");\n    }\n    if (boundary == null) {\n      throw Error(\"Boundary cannot be null\");\n    }\n    var result = new LayoutLevel2(node, boundary);\n    this._layoutStack.push(result);\n    if (this.BoundaryChanged) {\n      this.BoundaryChanged(this, new BoundaryChangedEventArgs2(boundary, result, this));\n    }\n    return result;\n  }\n  MergeSpacer(spacer) {\n    if (this.CurrentOperation != Operation2.HorizontalLayout) {\n      throw new Error(\"Spacers can only be merged during horizontal layout\");\n    }\n    if (this._layoutStack.length == 0) {\n      throw new Error(\"Cannot merge spacers at top nesting level\");\n    }\n    const level = peek(this._layoutStack);\n    if (level == null) {\n      throw Error(\"Level is null\");\n    }\n    level.Boundary.MergeFromNode(spacer);\n    if (this.BoundaryChanged) {\n      this.BoundaryChanged(this, new BoundaryChangedEventArgs2(level.Boundary, level, this));\n    }\n  }\n  PopLayoutLevel() {\n    var _a, _b;\n    const innerLevel = this._layoutStack.pop();\n    if (innerLevel == null) {\n      throw Error(\"innerLevel is null\");\n    }\n    if (this.BoundaryChanged) {\n      this.BoundaryChanged(this, new BoundaryChangedEventArgs2(innerLevel.Boundary, innerLevel, this));\n    }\n    if (this._layoutStack.length > 0) {\n      const higherLevel = peek(this._layoutStack);\n      if (higherLevel == null) {\n        throw Error(\"higherLevel is null\");\n      }\n      switch (this.CurrentOperation) {\n        case Operation2.VerticalLayout:\n          higherLevel.Boundary.VerticalMergeFrom(innerLevel.Boundary);\n          higherLevel.BranchRoot.State.BranchExterior = higherLevel.Boundary.BoundingRect;\n          break;\n        case Operation2.HorizontalLayout:\n          {\n            if (higherLevel.BranchRoot.AssistantsRoot != innerLevel.BranchRoot) {\n              const strategy = higherLevel.BranchRoot.State.RequireLayoutStrategy;\n              const overlap = higherLevel.Boundary.ComputeOverlap(innerLevel.Boundary, strategy.SiblingSpacing, this.Diagram.LayoutSettings.BranchSpacing);\n              if (overlap > 0) {\n                LayoutAlgorithm2.MoveBranch(this, innerLevel, overlap);\n                if (this.BoundaryChanged) {\n                  this.BoundaryChanged(this, new BoundaryChangedEventArgs2(innerLevel.Boundary, innerLevel, this));\n                }\n              }\n            }\n            higherLevel.Boundary.MergeFrom(innerLevel.Boundary);\n            higherLevel.BranchRoot.State.BranchExterior = new Rect2(higherLevel.Boundary.BoundingRect.Left, (_a = higherLevel.BranchRoot.State.BranchExterior) == null ? void 0 : _a.Top, higherLevel.Boundary.BoundingRect.Size.Width, (_b = higherLevel.BranchRoot.State.BranchExterior) == null ? void 0 : _b.Size.Height);\n          }\n          break;\n        default:\n          throw new Error(\"This operation can only be invoked when performing vertical or horizontal layouts\");\n      }\n      if (this.BoundaryChanged) {\n        this.BoundaryChanged(this, new BoundaryChangedEventArgs2(higherLevel.Boundary, higherLevel, this));\n      }\n    }\n    this._pooledBoundaries.push(innerLevel.Boundary);\n  }\n}\n","import BranchParentAlignment2 from \"./BranchParentAlignment\";\nexport default class LayoutStrategyBase {\n  constructor() {\n    this.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    this.ParentChildSpacing = 20;\n    this.ParentConnectorShield = 50;\n    this.SiblingSpacing = 20;\n    this.ChildConnectorHookLength = 5;\n  }\n  get SupportsAssistants() {\n    return this.GetSupportsAssistants();\n  }\n}\n","import Point2 from \"./Point\";\nimport LayoutStrategyBase2 from \"./LayoutStrategyBase\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport Box2 from \"./Box\";\nimport BranchParentAlignment2 from \"./BranchParentAlignment\";\nimport Rect2 from \"./Rect\";\nimport Edge2 from \"./Edge\";\nimport Connector2 from \"./Connector\";\nexport default class LinearLayoutStrategy extends LayoutStrategyBase2 {\n  constructor() {\n    super(...arguments);\n    this.GetSupportsAssistants = () => true;\n  }\n  PreProcessThisNode(state, node) {\n    if (node.ChildCount > 0) {\n      node.State.NumberOfSiblings = node.Element.IsCollapsed ? 0 : node.ChildCount;\n      if (!node.Element.IsCollapsed) {\n        const verticalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.AddRegularChildBox(verticalSpacer);\n        const horizontalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.AddRegularChildBox(horizontalSpacer);\n      }\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.CopyExteriorFrom(node.AssistantsRoot.State, node.State);\n      LayoutAlgorithm2.VerticalLayout(state, node.AssistantsRoot);\n    }\n    if (node.State.NumberOfSiblings == 0) {\n      return;\n    }\n    let siblingsRowExterior = Dimensions2.MinMax();\n    let top;\n    if (node.AssistantsRoot == null) {\n      if (node.State.SiblingsRowV == null) {\n        throw Error(\"SiblingsRowV is null\");\n      }\n      top = node.State.SiblingsRowV.To + this.ParentChildSpacing;\n    } else {\n      top = node.State.BranchExterior.Bottom + this.ParentChildSpacing;\n    }\n    for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n      let child = node.Children[i];\n      let rect = child.State;\n      LayoutAlgorithm2.MoveTo(child.State, 0, top);\n      if (child.State.Size == null) {\n        throw Error(\"Size is null\");\n      }\n      child.State.BranchExterior = Rect2.from(child.State.Size, child.State.TopLeft);\n      if (rect.Size == null) {\n        throw Error(\"Size is null\");\n      }\n      siblingsRowExterior = Dimensions2.add(siblingsRowExterior, new Dimensions2(top, top + rect.Size.Height));\n    }\n    siblingsRowExterior = new Dimensions2(siblingsRowExterior.From, siblingsRowExterior.To);\n    for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n      let child = node.Children[i];\n      child.State.SiblingsRowV = siblingsRowExterior;\n      LayoutAlgorithm2.VerticalLayout(state, child);\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.HorizontalLayout(state, node.AssistantsRoot);\n    }\n    for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n      let child = node.Children[i];\n      LayoutAlgorithm2.HorizontalLayout(state, child);\n    }\n    if (node.Level > 0 && node.ChildCount > 0) {\n      let rect = node.State;\n      let leftmost = node.Children[0].State.CenterH;\n      let rightmost = node.Children[node.State.NumberOfSiblings - 1].State.CenterH;\n      let desiredCenter = node.State.NumberOfSiblings == 1 || this.ParentAlignment == BranchParentAlignment2.Center ? leftmost + (rightmost - leftmost) / 2 : this.ParentAlignment == BranchParentAlignment2.Left ? leftmost + this.ChildConnectorHookLength : rightmost - this.ChildConnectorHookLength;\n      let center = rect.CenterH;\n      let diff = center - desiredCenter;\n      LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n      let verticalSpacer = node.Children[node.State.NumberOfSiblings];\n      if (node.Children[0].State.SiblingsRowV == null) {\n        throw Error(\"SiblingsRowV is null\");\n      }\n      LayoutAlgorithm2.AdjustSpacer(verticalSpacer.State, center - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);\n      state.MergeSpacer(verticalSpacer);\n      let firstInRow = node.Children[0].State;\n      let horizontalSpacer = node.Children[node.State.NumberOfSiblings + 1];\n      if (firstInRow.SiblingsRowV == null) {\n        throw Error(\"SiblingsRowV is null\");\n      }\n      LayoutAlgorithm2.AdjustSpacer(horizontalSpacer.State, firstInRow.Left, firstInRow.SiblingsRowV.From - this.ParentChildSpacing, node.Children[node.State.NumberOfSiblings - 1].State.Right - firstInRow.Left, this.ParentChildSpacing);\n      state.MergeSpacer(horizontalSpacer);\n    }\n  }\n  RouteConnectors(state, node) {\n    let normalChildCount = node.State.NumberOfSiblings;\n    let count = normalChildCount == 0 ? 0 : normalChildCount == 1 ? 1 : 1 + 1 + normalChildCount;\n    if (count == 0) {\n      node.State.Connector = null;\n      return;\n    }\n    let segments = [];\n    let rootRect = node.State;\n    let center = rootRect.CenterH;\n    if (node.Children == null) {\n      throw new Error(\"State is present, but children not set\");\n    }\n    if (count == 1) {\n      segments[0] = new Edge2(new Point2(center, rootRect.Bottom), new Point2(center, node.Children[0].State.Top));\n    } else {\n      if (node.Children[0].State.SiblingsRowV == null) {\n        throw Error(\"SiblingsRowV is null\");\n      }\n      let space = node.Children[0].State.SiblingsRowV.From - rootRect.Bottom;\n      segments[0] = new Edge2(new Point2(center, rootRect.Bottom), new Point2(center, rootRect.Bottom + space - this.ChildConnectorHookLength));\n      for (let i = 0; i < normalChildCount; i++) {\n        let childRect = node.Children[i].State;\n        let childCenter = childRect.CenterH;\n        segments[1 + i] = new Edge2(new Point2(childCenter, childRect.Top), new Point2(childCenter, childRect.Top - this.ChildConnectorHookLength));\n      }\n      segments[count - 1] = new Edge2(new Point2(segments[1].To.X, segments[1].To.Y), new Point2(segments[count - 2].To.X, segments[1].To.Y));\n    }\n    node.State.Connector = new Connector2(segments);\n  }\n}\n","import LinearLayoutStrategy2 from \"./LinearLayoutStrategy\";\nimport LayoutStrategyBase2 from \"./LayoutStrategyBase\";\nimport Node2 from \"./Node\";\nimport Box2 from \"./Box\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport BranchParentAlignment2 from \"./BranchParentAlignment\";\nimport Edge2 from \"./Edge\";\nimport Point2 from \"./Point\";\nimport Connector2 from \"./Connector\";\nimport Rect2 from \"./Rect\";\nclass GroupIterator {\n  constructor(numberOfSiblings, numberOfGroups) {\n    this.Group = 0;\n    this.FromIndex = 0;\n    this.Count = 0;\n    this.MaxOnLeft = 0;\n    this._numberOfSiblings = numberOfSiblings;\n    this._numberOfGroups = numberOfGroups;\n  }\n  CountInGroup() {\n    let countInRow = this._numberOfGroups * 2;\n    let result = 0;\n    let countToThisGroup = this.Group * 2 + 2;\n    let firstInRow = 0;\n    while (true) {\n      let countInThisRow = firstInRow >= this._numberOfSiblings - countInRow ? this._numberOfSiblings - firstInRow : countInRow;\n      if (countInThisRow >= countToThisGroup) {\n        result += 2;\n      } else {\n        countToThisGroup--;\n        if (countInThisRow >= countToThisGroup) {\n          result++;\n        }\n        break;\n      }\n      firstInRow += countInRow;\n    }\n    return result;\n  }\n  NextGroup() {\n    this.FromIndex = this.FromIndex + this.Count;\n    if (this.FromIndex > 0) {\n      this.Group++;\n    }\n    this.Count = this.CountInGroup();\n    this.MaxOnLeft = Math.floor(this.Count / 2) + this.Count % 2;\n    return this.Count != 0;\n  }\n}\nclass TreeNodeView extends Node2 {\n  constructor(element) {\n    super(element);\n  }\n  Prepare(capacity) {\n    if (this.Children == null) {\n      this.Children = [];\n    } else {\n      this.Children.length = 0;\n    }\n  }\n  AddChildView(node) {\n    this.Children.push(node);\n  }\n}\nclass SingleFishboneLayoutAdapter extends LayoutStrategyBase2 {\n  constructor(realRoot) {\n    super();\n    this.GetSupportsAssistants = () => false;\n    this.Iterator = new GroupIterator(realRoot.State.NumberOfSiblings, realRoot.State.NumberOfSiblingColumns);\n    this.RealRoot = realRoot;\n    this.SpecialRoot = new TreeNodeView(Box2.Special(Box2.None, realRoot.Element.Id, true));\n    this.SpecialRoot.Level = this.RealRoot.Level, this.SpecialRoot.ParentNode = this.RealRoot;\n    this.SpecialRoot.State.EffectiveLayoutStrategy = this;\n    let parentStrategy = realRoot.State.RequireLayoutStrategy;\n    this.SiblingSpacing = parentStrategy.SiblingSpacing;\n    this.ParentConnectorShield = parentStrategy.ParentConnectorShield;\n    this.ParentChildSpacing = parentStrategy.ParentChildSpacing;\n    this.ParentAlignment = parentStrategy.ParentAlignment;\n    this.ChildConnectorHookLength = parentStrategy.ChildConnectorHookLength;\n  }\n  NextGroup() {\n    if (!this.Iterator.NextGroup()) {\n      return false;\n    }\n    this.SpecialRoot.State.NumberOfSiblings = this.Iterator.Count;\n    this.SpecialRoot.Prepare(this.RealRoot.State.NumberOfSiblingRows * 2);\n    for (let i = 0; i < this.Iterator.Count; i++) {\n      this.SpecialRoot.AddChildView(this.RealRoot.Children[this.Iterator.FromIndex + i]);\n    }\n    let spacer = this.RealRoot.Children[this.RealRoot.State.NumberOfSiblings + 1 + this.Iterator.Group];\n    this.SpecialRoot.AddChildView(spacer);\n    LayoutAlgorithm2.CopyExteriorFrom(this.SpecialRoot.State, this.RealRoot.State);\n    return true;\n  }\n  PreProcessThisNode(state, node) {\n    throw new Error(\"NotSupportedException\");\n  }\n  ApplyVerticalLayout(state, level) {\n    var _a, _b;\n    if (this.SpecialRoot.State.SiblingsRowV == null) {\n      throw Error(\"SiblingsRowV is null\");\n    }\n    let prevRowBottom = (_b = (_a = this.RealRoot.AssistantsRoot) == null ? void 0 : _a.State.BranchExterior.Bottom) != null ? _b : this.SpecialRoot.State.SiblingsRowV.To;\n    for (let i = 0; i < this.Iterator.MaxOnLeft; i++) {\n      let spacing = i == 0 ? this.ParentChildSpacing : this.SiblingSpacing;\n      let child = this.SpecialRoot.Children[i];\n      let frame = child.State;\n      LayoutAlgorithm2.MoveTo(frame, frame.Left, prevRowBottom + spacing);\n      let rowExterior = new Dimensions2(frame.Top, frame.Bottom);\n      let i2 = i + this.Iterator.MaxOnLeft;\n      if (frame.Size == null) {\n        throw Error(\"Size is null\");\n      }\n      if (i2 < this.Iterator.Count) {\n        let child2 = this.SpecialRoot.Children[i2];\n        let frame2 = child2.State;\n        LayoutAlgorithm2.MoveTo(frame2, frame2.Left, prevRowBottom + spacing);\n        if (frame2.Size == null) {\n          throw Error(\"Size is null\");\n        }\n        if (frame2.Bottom > frame.Bottom) {\n          LayoutAlgorithm2.MoveTo(frame, frame.Left, frame2.CenterV - frame.Size.Height / 2);\n        } else if (frame2.Bottom < frame.Bottom) {\n          LayoutAlgorithm2.MoveTo(frame2, frame2.Left, frame.CenterV - frame2.Size.Height / 2);\n        }\n        frame2.BranchExterior = Rect2.from(frame2.Size, frame2.TopLeft);\n        rowExterior = Dimensions2.add(rowExterior, new Dimensions2(frame2.Top, frame2.Bottom));\n        frame2.SiblingsRowV = rowExterior;\n        LayoutAlgorithm2.VerticalLayout(state, child2);\n        prevRowBottom = frame2.BranchExterior.Bottom;\n      }\n      frame.BranchExterior = Rect2.from(frame.Size, frame.TopLeft);\n      frame.SiblingsRowV = rowExterior;\n      LayoutAlgorithm2.VerticalLayout(state, child);\n      prevRowBottom = Math.max(prevRowBottom, frame.BranchExterior.Bottom);\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    if (level.BranchRoot != this.SpecialRoot) {\n      throw new Error(\"InvalidOperationException: Wrong root node received\");\n    }\n    let left = true;\n    let countOnThisSide = 0;\n    for (let i = 0; i < this.Iterator.Count; i++) {\n      let child = this.SpecialRoot.Children[i];\n      LayoutAlgorithm2.HorizontalLayout(state, child);\n      if (++countOnThisSide == this.Iterator.MaxOnLeft) {\n        if (left) {\n          LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateSiblings(0, this.Iterator.MaxOnLeft));\n          left = false;\n          countOnThisSide = 0;\n          let rightmost = Number.MIN_VALUE;\n          for (let k = 0; k < i; k++) {\n            rightmost = Math.max(rightmost, this.SpecialRoot.Children[k].State.BranchExterior.Right);\n          }\n          rightmost = Math.max(rightmost, child.State.Right);\n          let spacer = this.SpecialRoot.Children[this.SpecialRoot.State.NumberOfSiblings];\n          if (this.SpecialRoot.Children[0].State.SiblingsRowV == null) {\n            throw Error(\"SiblingsRowV is null\");\n          }\n          if (child.State.SiblingsRowV == null) {\n            throw Error(\"SiblingsRowV is null\");\n          }\n          LayoutAlgorithm2.AdjustSpacer(spacer.State, rightmost, this.SpecialRoot.Children[0].State.SiblingsRowV.From, this.SiblingSpacing, child.State.SiblingsRowV.To - this.SpecialRoot.Children[0].State.SiblingsRowV.From);\n          level.Boundary.MergeFromNode(spacer);\n        }\n      }\n    }\n    LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateSiblings(this.Iterator.MaxOnLeft, this.Iterator.Count));\n  }\n  EnumerateSiblings(from, to) {\n    const nodes = [];\n    for (let i = from; i < to; i++) {\n      nodes.push(this.SpecialRoot.Children[i]);\n    }\n    return nodes;\n  }\n  RouteConnectors(state, node) {\n    throw new Error();\n  }\n}\nexport default class MultiLineFishboneLayoutStrategy extends LinearLayoutStrategy2 {\n  constructor() {\n    super(...arguments);\n    this.MaxGroups = 4;\n    this.GetSupportsAssistants = () => true;\n  }\n  PreProcessThisNode(state, node) {\n    if (this.MaxGroups <= 0) {\n      throw new Error(\"MaxGroups must be a positive value\");\n    }\n    if (node.ChildCount <= this.MaxGroups * 2) {\n      super.PreProcessThisNode(state, node);\n      return;\n    }\n    node.State.NumberOfSiblings = node.ChildCount;\n    if (node.State.NumberOfSiblings > 0) {\n      node.State.NumberOfSiblingColumns = this.MaxGroups;\n      node.State.NumberOfSiblingRows = Math.floor(node.State.NumberOfSiblings / (this.MaxGroups * 2));\n      if (node.State.NumberOfSiblings % (this.MaxGroups * 2) != 0) {\n        node.State.NumberOfSiblingRows++;\n      }\n      let parentSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n      node.AddRegularChildBox(parentSpacer);\n      for (let i = 0; i < node.State.NumberOfSiblingColumns; i++) {\n        let verticalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.AddRegularChildBox(verticalSpacer);\n      }\n      if (node.State.NumberOfSiblingColumns > 1) {\n        let horizontalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.AddRegularChildBox(horizontalSpacer);\n      }\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {\n      super.ApplyVerticalLayout(state, level);\n      return;\n    }\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.CopyExteriorFrom(node.AssistantsRoot.State, node.State);\n      LayoutAlgorithm2.VerticalLayout(state, node.AssistantsRoot);\n    }\n    let adapter = new SingleFishboneLayoutAdapter(node);\n    while (adapter.NextGroup()) {\n      LayoutAlgorithm2.VerticalLayout(state, adapter.SpecialRoot);\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {\n      super.ApplyHorizontalLayout(state, level);\n      return;\n    }\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.HorizontalLayout(state, node.AssistantsRoot);\n    }\n    let adapter = new SingleFishboneLayoutAdapter(node);\n    while (adapter.NextGroup()) {\n      LayoutAlgorithm2.HorizontalLayout(state, adapter.SpecialRoot);\n    }\n    let rect = node.State;\n    if (node.Level > 0) {\n      let diff = 0;\n      if (node.State.NumberOfSiblingColumns > 1) {\n        let leftCarrier = node.Children[node.State.NumberOfSiblings + 1].State.CenterH;\n        let rightCarrier = node.Children[node.State.NumberOfSiblings + node.State.NumberOfSiblingColumns].State.CenterH;\n        let desiredCenter = node.State.NumberOfSiblings == 1 || this.ParentAlignment == BranchParentAlignment2.Center ? leftCarrier + (rightCarrier - leftCarrier) / 2 : this.ParentAlignment == BranchParentAlignment2.Left ? leftCarrier + this.ChildConnectorHookLength : rightCarrier - this.ChildConnectorHookLength;\n        diff = rect.CenterH - desiredCenter;\n      } else {\n        let carrier = node.Children[1 + node.State.NumberOfSiblings].State.CenterH;\n        let desiredCenter = rect.CenterH;\n        diff = desiredCenter - carrier;\n      }\n      LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n    }\n    if (node.Level > 0) {\n      if (node.Children[0].State.SiblingsRowV == null) {\n        throw Error(\"SiblingsRowV is null\");\n      }\n      let ix = node.State.NumberOfSiblings;\n      let verticalSpacer = node.Children[ix];\n      LayoutAlgorithm2.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);\n      state.MergeSpacer(verticalSpacer);\n      ix++;\n      ix += node.State.NumberOfSiblingColumns;\n      if (node.State.NumberOfSiblingColumns > 1) {\n        let horizontalSpacer = node.Children[ix];\n        let leftmost = node.Children[node.State.NumberOfSiblings + 1].State.TopLeft;\n        let rightmost = node.Children[ix - 1].State.Right;\n        LayoutAlgorithm2.AdjustSpacer(horizontalSpacer.State, leftmost.X, leftmost.Y - this.ParentChildSpacing, rightmost - leftmost.X, this.ParentChildSpacing);\n        state.MergeSpacer(horizontalSpacer);\n      }\n    }\n  }\n  RouteConnectors(state, node) {\n    if (node.State.NumberOfSiblings <= this.MaxGroups * 2) {\n      super.RouteConnectors(state, node);\n      return;\n    }\n    let count = 1 + node.State.NumberOfSiblings + node.State.NumberOfSiblingColumns;\n    if (node.State.NumberOfSiblingColumns > 1) {\n      count++;\n    }\n    let segments = [];\n    let rootRect = node.State;\n    let center = rootRect.CenterH;\n    let ix = 0;\n    if (node.Children[0].State.SiblingsRowV == null) {\n      throw Error(\"SiblingsRowV is null\");\n    }\n    let space = node.Children[0].State.SiblingsRowV.From - rootRect.Bottom;\n    segments[ix++] = new Edge2(new Point2(center, rootRect.Bottom), new Point2(center, rootRect.Bottom + space - this.ChildConnectorHookLength));\n    let iterator = new GroupIterator(node.State.NumberOfSiblings, node.State.NumberOfSiblingColumns);\n    while (iterator.NextGroup()) {\n      let carrier = node.Children[1 + node.State.NumberOfSiblings + iterator.Group].State;\n      let from = carrier.CenterH;\n      let isLeft = true;\n      let countOnThisSide = 0;\n      for (let i = iterator.FromIndex; i < iterator.FromIndex + iterator.Count; i++) {\n        let to = isLeft ? node.Children[i].State.Right : node.Children[i].State.Left;\n        let y = node.Children[i].State.CenterV;\n        segments[ix++] = new Edge2(new Point2(from, y), new Point2(to, y));\n        if (++countOnThisSide == iterator.MaxOnLeft) {\n          countOnThisSide = 0;\n          if (isLeft) {\n            segments[1 + node.State.NumberOfSiblings + iterator.Group] = new Edge2(new Point2(carrier.CenterH, carrier.Top - this.ChildConnectorHookLength), new Point2(carrier.CenterH, node.Children[i].State.CenterV));\n          }\n          isLeft = !isLeft;\n        }\n      }\n    }\n    ix += node.State.NumberOfSiblingColumns;\n    if (node.State.NumberOfSiblingColumns > 1) {\n      let leftGroup = node.Children[1 + node.State.NumberOfSiblings].State;\n      let rightGroup = node.Children[1 + node.State.NumberOfSiblings + node.State.NumberOfSiblingColumns - 1].State;\n      segments[ix] = new Edge2(new Point2(leftGroup.CenterH, leftGroup.Top - this.ChildConnectorHookLength), new Point2(rightGroup.CenterH, rightGroup.Top - this.ChildConnectorHookLength));\n    }\n    node.State.Connector = new Connector2(segments);\n  }\n}\n","import LinearLayoutStrategy2 from \"./LinearLayoutStrategy\";\nimport Box2 from \"./Box\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport Edge2 from \"./Edge\";\nimport Point2 from \"./Point\";\nimport Connector2 from \"./Connector\";\nimport Rect2 from \"./Rect\";\nexport default class MultiLineHangerLayoutStrategy extends LinearLayoutStrategy2 {\n  constructor() {\n    super(...arguments);\n    this.MaxSiblingsPerRow = 4;\n    this.GetSupportsAssistants = () => true;\n  }\n  PreProcessThisNode(state, node) {\n    if (this.MaxSiblingsPerRow <= 0 || this.MaxSiblingsPerRow % 2 != 0) {\n      throw new Error(\"MaxSiblingsPerRow must be a positive even value\");\n    }\n    if (node.ChildCount <= this.MaxSiblingsPerRow) {\n      super.PreProcessThisNode(state, node);\n      return;\n    }\n    node.State.NumberOfSiblings = node.ChildCount;\n    if (node.State.NumberOfSiblings > 0) {\n      let lastRowBoxCount = node.ChildCount % this.MaxSiblingsPerRow;\n      node.State.NumberOfSiblingColumns = 1 + this.MaxSiblingsPerRow;\n      node.State.NumberOfSiblingRows = Math.floor(node.ChildCount / this.MaxSiblingsPerRow);\n      if (lastRowBoxCount != 0) {\n        node.State.NumberOfSiblingRows++;\n      }\n      node.State.NumberOfSiblings = node.ChildCount + node.State.NumberOfSiblingRows;\n      if (lastRowBoxCount > 0 && lastRowBoxCount <= Math.floor(this.MaxSiblingsPerRow / 2)) {\n        node.State.NumberOfSiblings--;\n      }\n      let ix = Math.floor(this.MaxSiblingsPerRow / 2);\n      while (ix < node.State.NumberOfSiblings) {\n        let siblingSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.InsertRegularChildBoxByIndex(ix, siblingSpacer);\n        ix += node.State.NumberOfSiblingColumns;\n      }\n      let verticalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n      node.AddRegularChildBox(verticalSpacer);\n      for (let i = 0; i < node.State.NumberOfSiblingRows; i++) {\n        let horizontalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n        node.AddRegularChildBox(horizontalSpacer);\n      }\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {\n      super.ApplyVerticalLayout(state, level);\n      return;\n    }\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.CopyExteriorFrom(node.AssistantsRoot.State, node.State);\n      LayoutAlgorithm2.VerticalLayout(state, node.AssistantsRoot);\n    }\n    let prevRowExterior = new Dimensions2(node.State.SiblingsRowV.From, node.AssistantsRoot == null ? node.State.SiblingsRowV.To : node.State.BranchExterior.Bottom);\n    for (let row = 0; row < node.State.NumberOfSiblingRows; row++) {\n      let siblingsRowExterior = Dimensions2.MinMax();\n      let spacing = row == 0 ? this.ParentChildSpacing : this.SiblingSpacing;\n      let from = row * node.State.NumberOfSiblingColumns;\n      let to = Math.min(from + node.State.NumberOfSiblingColumns, node.State.NumberOfSiblings);\n      for (let i = from; i < to; i++) {\n        let child = node.Children[i];\n        if (child.Element.IsSpecial) {\n          continue;\n        }\n        let rect = child.State;\n        let top = prevRowExterior.To + spacing;\n        LayoutAlgorithm2.MoveTo(child.State, rect.Left, top);\n        child.State.BranchExterior = Rect2.from(child.State.Size, child.State.TopLeft);\n        siblingsRowExterior = Dimensions2.add(siblingsRowExterior, new Dimensions2(top, top + rect.Size.Height));\n      }\n      siblingsRowExterior = new Dimensions2(siblingsRowExterior.From, siblingsRowExterior.To);\n      let siblingsBottom = Number.MIN_VALUE;\n      for (let i = from; i < to; i++) {\n        let child = node.Children[i];\n        child.State.SiblingsRowV = siblingsRowExterior;\n        LayoutAlgorithm2.VerticalLayout(state, child);\n        siblingsBottom = Math.max(siblingsBottom, child.State.BranchExterior.Bottom);\n      }\n      prevRowExterior = new Dimensions2(siblingsRowExterior.From, Math.max(siblingsBottom, siblingsRowExterior.To));\n      let spacerIndex = from + Math.floor(node.State.NumberOfSiblingColumns / 2);\n      if (spacerIndex < node.State.NumberOfSiblings) {\n        let spacerBottom = row == node.State.NumberOfSiblingRows - 1 ? node.Children[spacerIndex - 1].State.SiblingsRowV.To : prevRowExterior.To;\n        let spacer = node.Children[spacerIndex].State;\n        LayoutAlgorithm2.AdjustSpacer(spacer, 0, prevRowExterior.From, this.ParentConnectorShield, spacerBottom - prevRowExterior.From);\n      }\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {\n      super.ApplyHorizontalLayout(state, level);\n      return;\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.HorizontalLayout(state, node.AssistantsRoot);\n    }\n    for (let col = 0; col < node.State.NumberOfSiblingColumns; col++) {\n      for (let row = 0; row < node.State.NumberOfSiblingRows; row++) {\n        let ix = row * node.State.NumberOfSiblingColumns + col;\n        if (ix >= node.State.NumberOfSiblings) {\n          break;\n        }\n        let child = node.Children[ix];\n        LayoutAlgorithm2.HorizontalLayout(state, child);\n      }\n      LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateColumn(node, col));\n    }\n    let rect = node.State;\n    let spacer = node.Children[Math.floor(node.State.NumberOfSiblingColumns / 2)];\n    let desiredCenter = spacer.State.CenterH;\n    let diff = rect.CenterH - desiredCenter;\n    LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n    let verticalSpacer = node.Children[node.State.NumberOfSiblings];\n    LayoutAlgorithm2.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, rect.Bottom, this.ParentConnectorShield, node.Children[0].State.SiblingsRowV.From - rect.Bottom);\n    state.MergeSpacer(verticalSpacer);\n    let spacing = this.ParentChildSpacing;\n    for (let firstInRowIndex = 0; firstInRowIndex < node.State.NumberOfSiblings; firstInRowIndex += node.State.NumberOfSiblingColumns) {\n      let firstInRow = node.Children[firstInRowIndex].State;\n      let lastInRow = node.Children[Math.min(firstInRowIndex + node.State.NumberOfSiblingColumns - 1, node.State.NumberOfSiblings - 1)].State;\n      let horizontalSpacer = node.Children[1 + node.State.NumberOfSiblings + Math.floor(firstInRowIndex / node.State.NumberOfSiblingColumns)];\n      let width = lastInRow.Right >= verticalSpacer.State.Right ? lastInRow.Right - firstInRow.Left : verticalSpacer.State.Right - firstInRow.Left;\n      LayoutAlgorithm2.AdjustSpacer(horizontalSpacer.State, firstInRow.Left, firstInRow.SiblingsRowV.From - spacing, width, spacing);\n      state.MergeSpacer(horizontalSpacer);\n      spacing = this.SiblingSpacing;\n    }\n  }\n  EnumerateColumn(branchRoot, col) {\n    const nodes = [];\n    for (let row = 0; row < branchRoot.State.NumberOfSiblingRows; row++) {\n      let ix = row * branchRoot.State.NumberOfSiblingColumns + col;\n      if (ix >= branchRoot.State.NumberOfSiblings) {\n        break;\n      }\n      nodes.push(branchRoot.Children[ix]);\n    }\n    return nodes;\n  }\n  RouteConnectors(state, node) {\n    if (node.State.NumberOfSiblings <= this.MaxSiblingsPerRow) {\n      super.RouteConnectors(state, node);\n      return;\n    }\n    let count = 1 + node.State.NumberOfSiblingRows;\n    for (let child of node.Children) {\n      if (!child.Element.IsSpecial) {\n        count++;\n      }\n    }\n    let segments = [];\n    let rootRect = node.State;\n    let center = rootRect.CenterH;\n    let verticalCarrierHeight = node.Children[node.State.NumberOfSiblings - 1].State.SiblingsRowV.From - this.ChildConnectorHookLength - rootRect.Bottom;\n    segments[0] = new Edge2(new Point2(center, rootRect.Bottom), new Point2(center, rootRect.Bottom + verticalCarrierHeight));\n    let ix = 1;\n    for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n      let child = node.Children[i];\n      if (!child.Element.IsSpecial) {\n        let childRect = child.State;\n        let childCenter = childRect.CenterH;\n        segments[ix++] = new Edge2(new Point2(childCenter, childRect.Top), new Point2(childCenter, childRect.Top - this.ChildConnectorHookLength));\n      }\n    }\n    let lastChildHookIndex = count - node.State.NumberOfSiblingRows - 1;\n    for (let firstInRowIndex = 1; firstInRowIndex < count - node.State.NumberOfSiblingRows; firstInRowIndex += this.MaxSiblingsPerRow) {\n      let firstInRow = segments[firstInRowIndex];\n      let lastInRow = segments[Math.min(firstInRowIndex + this.MaxSiblingsPerRow - 1, lastChildHookIndex)];\n      if (lastInRow.From.X < segments[0].From.X) {\n        segments[ix++] = new Edge2(new Point2(firstInRow.To.X, firstInRow.To.Y), new Point2(segments[0].To.X, firstInRow.To.Y));\n      } else {\n        segments[ix++] = new Edge2(new Point2(firstInRow.To.X, firstInRow.To.Y), new Point2(lastInRow.To.X, firstInRow.To.Y));\n      }\n    }\n    node.State.Connector = new Connector2(segments);\n  }\n}\n","import Size2 from \"./Size\";\nimport Point2 from \"./Point\";\nimport Dimensions2 from \"./Dimensions\";\nimport Rect2 from \"./Rect\";\nexport default class NodeLayoutInfo {\n  constructor() {\n    this._effectiveLayoutStrategy = null;\n    this.IsHidden = false;\n    this.Connector = null;\n    this.NumberOfSiblings = 0;\n    this.NumberOfSiblingRows = 0;\n    this.NumberOfSiblingColumns = 0;\n    this.Size = new Size2(0, 0);\n    this.TopLeft = new Point2(0, 0);\n    this.BranchExterior = new Rect2(0, 0, 0, 0);\n    this.SiblingsRowV = new Dimensions2(0, 0);\n  }\n  set EffectiveLayoutStrategy(value) {\n    this._effectiveLayoutStrategy = value;\n  }\n  get RequireLayoutStrategy() {\n    if (this._effectiveLayoutStrategy == null) {\n      throw new Error(\"EffectiveLayoutStrategy is not set\");\n    }\n    return this._effectiveLayoutStrategy;\n  }\n  get Left() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    return this.TopLeft.X;\n  }\n  get Right() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    if (this.Size == null) {\n      throw Error(\"Size is null\");\n    }\n    return this.TopLeft.X + this.Size.Width;\n  }\n  get Top() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    if (this.Size == null) {\n      throw Error(\"Size is null\");\n    }\n    return this.TopLeft.Y;\n  }\n  get Bottom() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    if (this.Size == null) {\n      throw Error(\"Size is null\");\n    }\n    return this.TopLeft.Y + this.Size.Height;\n  }\n  get CenterH() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    if (this.Size == null) {\n      throw Error(\"Size is null\");\n    }\n    return this.TopLeft.X + this.Size.Width / 2;\n  }\n  get CenterV() {\n    if (this.TopLeft == null) {\n      throw Error(\"TopLeft is null\");\n    }\n    if (this.Size == null) {\n      throw Error(\"Size is null\");\n    }\n    return this.TopLeft.Y + this.Size.Height / 2;\n  }\n}\n","import Box2 from \"./Box\";\nimport NodeLayoutInfo2 from \"./NodeLayoutInfo\";\nexport default class Node {\n  constructor(element) {\n    this.Level = 0;\n    this.Children = [];\n    this.AssistantsRoot = null;\n    this.ParentNode = null;\n    this.Element = element;\n    this.State = new NodeLayoutInfo2();\n  }\n  get ChildCount() {\n    var _a;\n    return ((_a = this.Children) == null ? void 0 : _a.length) || 0;\n  }\n  get IsAssistantRoot() {\n    var _a;\n    return ((_a = this.ParentNode) == null ? void 0 : _a.AssistantsRoot) == this;\n  }\n  AddAssistantChild(child) {\n    if (this.AssistantsRoot == null) {\n      this.AssistantsRoot = new Node(Box2.Special(Box2.None, this.Element.Id, true));\n      this.AssistantsRoot.ParentNode = this;\n      this.AssistantsRoot.Level = this.AssistantsRoot.Level + 1;\n    }\n    this.AssistantsRoot.AddRegularChild(child);\n    return this;\n  }\n  AddRegularChild(child) {\n    return this.InsertRegularChild(this.ChildCount, child);\n  }\n  AddRegularChildBox(child) {\n    return this.InsertRegularChildBoxByIndex(this.ChildCount, child);\n  }\n  InsertRegularChildBox(child) {\n    return this.InsertRegularChildBoxByIndex(this.ChildCount, child);\n  }\n  InsertRegularChildBoxByIndex(index, child) {\n    return this.InsertRegularChild(index, new Node(child));\n  }\n  InsertRegularChild(index, child) {\n    if (this.Children == null) {\n      this.Children = [];\n    }\n    this.Children.splice(index, 0, child);\n    child.ParentNode = this;\n    child.Level = this.Level + 1;\n    return this;\n  }\n  IterateChildFirst(func) {\n    if (this.AssistantsRoot != null) {\n      if (!this.AssistantsRoot.IterateChildFirst(func)) {\n        return false;\n      }\n    }\n    if (this.Children != null) {\n      for (const child of this.Children) {\n        if (!child.IterateChildFirst(func)) {\n          return false;\n        }\n      }\n    }\n    return func(this);\n  }\n  IterateParentFirst(enter, exit) {\n    var _a;\n    if (!enter(this)) {\n      if (exit) {\n        exit(this);\n      }\n      return false;\n    }\n    (_a = this.AssistantsRoot) == null ? void 0 : _a.IterateParentFirst(enter, exit);\n    if (this.Children != null) {\n      for (const child of this.Children) {\n        child.IterateParentFirst(enter, exit);\n      }\n    }\n    if (exit) {\n      exit(this);\n    }\n    return true;\n  }\n  SuppressAssistants() {\n    if (this.AssistantsRoot != null) {\n      for (const child of this.AssistantsRoot.Children) {\n        this.AddRegularChild(child);\n      }\n      this.AssistantsRoot = null;\n    }\n  }\n}\n","var Operation;\n(function(Operation2) {\n  Operation2[Operation2[\"Idle\"] = 0] = \"Idle\";\n  Operation2[Operation2[\"Preparing\"] = 1] = \"Preparing\";\n  Operation2[Operation2[\"PreprocessVisualTree\"] = 2] = \"PreprocessVisualTree\";\n  Operation2[Operation2[\"VerticalLayout\"] = 3] = \"VerticalLayout\";\n  Operation2[Operation2[\"HorizontalLayout\"] = 4] = \"HorizontalLayout\";\n  Operation2[Operation2[\"ConnectorsLayout\"] = 5] = \"ConnectorsLayout\";\n  Operation2[Operation2[\"Completed\"] = 6] = \"Completed\";\n})(Operation || (Operation = {}));\nexport default Operation;\n","export default class Point {\n  constructor(x, y) {\n    this.X = x;\n    this.Y = y;\n  }\n  MoveH(offsetX) {\n    return new Point(this.X + offsetX, this.Y);\n  }\n}\n","import Point2 from \"./Point\";\nimport Size2 from \"./Size\";\nexport default class Rect {\n  get BottomRight() {\n    return new Point2(this.TopLeft.X + this.Size.Width, this.TopLeft.Y + this.Size.Height);\n  }\n  get Left() {\n    return this.TopLeft.X;\n  }\n  get Right() {\n    return this.TopLeft.X + this.Size.Width;\n  }\n  get CenterH() {\n    return this.TopLeft.X + this.Size.Width / 2;\n  }\n  get CenterV() {\n    return this.TopLeft.Y + this.Size.Height / 2;\n  }\n  get Top() {\n    return this.TopLeft.Y;\n  }\n  get Bottom() {\n    return this.TopLeft.Y + this.Size.Height;\n  }\n  constructor(x, y, w, h) {\n    if (w < 0) {\n      throw new Error(`Width out of range`);\n    }\n    if (h < 0) {\n      throw new Error(`Height out of range`);\n    }\n    this.TopLeft = new Point2(x, y);\n    this.Size = new Size2(w, h);\n  }\n  static from(size, topLeft = new Point2(0, 0)) {\n    return new Rect(topLeft.X, topLeft.Y, size.Width, size.Height);\n  }\n  static add(x, y) {\n    const left = Math.min(x.Left, y.Left);\n    const top = Math.min(x.Top, y.Top);\n    const right = Math.max(x.Right, y.Right);\n    const bottom = Math.max(x.Bottom, y.Bottom);\n    return new Rect(left, top, right - left, bottom - top);\n  }\n  MoveH(offsetX) {\n    return Rect.from(this.Size, new Point2(this.Left + offsetX, this.Top));\n  }\n}\n","import LayoutStrategyBase2 from \"./LayoutStrategyBase\";\nimport Box2 from \"./Box\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport BranchParentAlignment2 from \"./BranchParentAlignment\";\nimport Edge2 from \"./Edge\";\nimport Point2 from \"./Point\";\nimport Connector2 from \"./Connector\";\nimport Rect2 from \"./Rect\";\nexport default class SingleColumnLayoutStrategy extends LayoutStrategyBase2 {\n  constructor() {\n    super(...arguments);\n    this.GetSupportsAssistants = () => true;\n  }\n  PreProcessThisNode(state, node) {\n    if (this.ParentAlignment != BranchParentAlignment2.Left && this.ParentAlignment != BranchParentAlignment2.Right) {\n      throw new Error(\"InvalidOperationException: Unsupported value for ParentAlignment\");\n    }\n    node.State.NumberOfSiblings = node.Element.IsCollapsed ? 0 : node.ChildCount;\n    if (node.State.NumberOfSiblings > 0 && node.Level > 0) {\n      node.State.NumberOfSiblingColumns = 1;\n      node.State.NumberOfSiblingRows = node.ChildCount;\n      let verticalSpacer = Box2.Special(Box2.None, node.Element.Id, false);\n      node.AddRegularChildBox(verticalSpacer);\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.CopyExteriorFrom(node.AssistantsRoot.State, node.State);\n      LayoutAlgorithm2.VerticalLayout(state, node.AssistantsRoot);\n    }\n    let prevRowExterior = new Dimensions2(node.State.SiblingsRowV.From, node.AssistantsRoot == null ? node.State.SiblingsRowV.To : node.State.BranchExterior.Bottom);\n    for (let row = 0; row < node.State.NumberOfSiblings; row++) {\n      let child = node.Children[row];\n      let rect = child.State;\n      let top = prevRowExterior.To + (row == 0 ? this.ParentChildSpacing : this.SiblingSpacing);\n      LayoutAlgorithm2.MoveTo(child.State, rect.Left, top);\n      child.State.BranchExterior = Rect2.from(child.State.Size, child.State.TopLeft);\n      let rowExterior = new Dimensions2(top, top + rect.Size.Height);\n      child = node.Children[row];\n      child.State.SiblingsRowV = rowExterior;\n      LayoutAlgorithm2.VerticalLayout(state, child);\n      let childBranchBottom = child.State.BranchExterior.Bottom;\n      prevRowExterior = new Dimensions2(rowExterior.From, Math.max(childBranchBottom, rowExterior.To));\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    let node = level.BranchRoot;\n    let nodeState = node.State;\n    if (node.AssistantsRoot != null) {\n      LayoutAlgorithm2.HorizontalLayout(state, node.AssistantsRoot);\n    }\n    for (let row = 0; row < nodeState.NumberOfSiblings; row++) {\n      let child = node.Children[row];\n      LayoutAlgorithm2.HorizontalLayout(state, child);\n    }\n    let edges = LayoutAlgorithm2.AlignHorizontalCenters(state, level, this.EnumerateColumn(node));\n    if (node.Level > 0 && node.ChildCount > 0) {\n      let rect = node.State;\n      let diff;\n      if (this.ParentAlignment == BranchParentAlignment2.Left) {\n        let desiredLeft = rect.CenterH + this.ParentConnectorShield / 2;\n        diff = desiredLeft - edges.From;\n      } else if (this.ParentAlignment == BranchParentAlignment2.Right) {\n        let desiredRight = rect.CenterH - this.ParentConnectorShield / 2;\n        diff = desiredRight - edges.To;\n      } else {\n        throw new Error(\"InvalidOperationException: Invalid ParentAlignment setting\");\n      }\n      LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n      let verticalSpacer = node.Level > 0 ? node.Children[node.ChildCount - 1] : null;\n      if (verticalSpacer != null) {\n        let spacerTop = node.State.Bottom;\n        let spacerBottom = node.Children[node.ChildCount - 2].State.Bottom;\n        LayoutAlgorithm2.AdjustSpacer(verticalSpacer.State, rect.CenterH - this.ParentConnectorShield / 2, spacerTop, this.ParentConnectorShield, spacerBottom - spacerTop);\n        state.MergeSpacer(verticalSpacer);\n      }\n    }\n  }\n  EnumerateColumn(branchRoot) {\n    const nodes = [];\n    for (let i = 0; i < branchRoot.State.NumberOfSiblings; i++) {\n      nodes.push(branchRoot.Children[i]);\n    }\n    return nodes;\n  }\n  RouteConnectors(state, node) {\n    if (node.ChildCount == 0) {\n      return;\n    }\n    let count = 1 + node.State.NumberOfSiblings;\n    let segments = Array(count);\n    let rootRect = node.State;\n    let center = rootRect.CenterH;\n    let verticalCarrierHeight = node.Children[node.State.NumberOfSiblings - 1].State.CenterV - node.State.Bottom;\n    segments[0] = new Edge2(new Point2(center, rootRect.Bottom), new Point2(center, rootRect.Bottom + verticalCarrierHeight));\n    for (let ix = 0; ix < node.State.NumberOfSiblings; ix++) {\n      let rect = node.Children[ix].State;\n      let destination = this.ParentAlignment == BranchParentAlignment2.Left ? rect.Left : rect.Right;\n      segments[1 + ix] = new Edge2(new Point2(center, rect.CenterV), new Point2(destination, rect.CenterV));\n    }\n    node.State.Connector = new Connector2(segments);\n  }\n}\n","export default class Size {\n  constructor(w, h) {\n    this.Width = w;\n    this.Height = h;\n  }\n}\n","var StackOrientation;\n(function(StackOrientation2) {\n  StackOrientation2[StackOrientation2[\"InvalidValue\"] = 0] = \"InvalidValue\";\n  StackOrientation2[StackOrientation2[\"SingleRowHorizontal\"] = 1] = \"SingleRowHorizontal\";\n  StackOrientation2[StackOrientation2[\"SingleColumnVertical\"] = 2] = \"SingleColumnVertical\";\n})(StackOrientation || (StackOrientation = {}));\nexport default StackOrientation;\n","import LayoutStrategyBase2 from \"./LayoutStrategyBase\";\nimport Dimensions2 from \"./Dimensions\";\nimport LayoutAlgorithm2 from \"./LayoutAlgorithm\";\nimport BranchParentAlignment2 from \"./BranchParentAlignment\";\nimport Size2 from \"./Size\";\nimport Rect2 from \"./Rect\";\nimport StackOrientation2 from \"./StackOrientation\";\nexport default class StackingLayoutStrategy extends LayoutStrategyBase2 {\n  constructor() {\n    super();\n    this.GetSupportsAssistants = () => false;\n    this.Orientation = StackOrientation2.SingleRowHorizontal;\n    this.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    this.ChildConnectorHookLength = 0;\n    this.ParentConnectorShield = 0;\n    this.SiblingSpacing = 5;\n  }\n  PreProcessThisNode(state, node) {\n    node.State.NumberOfSiblings = node.Element.IsCollapsed ? 0 : node.ChildCount;\n    if (node.State.NumberOfSiblings > 0) {\n      if (this.Orientation != StackOrientation2.SingleRowHorizontal && this.Orientation != StackOrientation2.SingleColumnVertical) {\n        throw new Error(\"InvalidOperationException: Unsupported value for orientation: \" + this.Orientation);\n      }\n    }\n  }\n  ApplyVerticalLayout(state, level) {\n    let node = level.BranchRoot;\n    if (node.Level == 0) {\n      node.State.SiblingsRowV = new Dimensions2(node.State.Top, node.State.Bottom);\n    }\n    if (node.State.NumberOfSiblings == 0) {\n      return;\n    }\n    let siblingsRowExterior = Dimensions2.MinMax();\n    if (this.Orientation == StackOrientation2.SingleRowHorizontal) {\n      let top = node.AssistantsRoot == null ? node.State.SiblingsRowV.To + this.ParentChildSpacing : node.State.BranchExterior.Bottom + this.ParentChildSpacing;\n      for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n        let child = node.Children[i];\n        let rect = child.State;\n        LayoutAlgorithm2.MoveTo(child.State, 0, top);\n        child.State.BranchExterior = Rect2.from(child.State.Size, child.State.TopLeft);\n        siblingsRowExterior = Dimensions2.add(siblingsRowExterior, new Dimensions2(top, top + rect.Size.Height));\n      }\n      siblingsRowExterior = new Dimensions2(siblingsRowExterior.From, siblingsRowExterior.To);\n      for (let i = 0; i < node.State.NumberOfSiblings; i++) {\n        let child = node.Children[i];\n        child.State.SiblingsRowV = siblingsRowExterior;\n        LayoutAlgorithm2.VerticalLayout(state, child);\n      }\n    } else if (this.Orientation == StackOrientation2.SingleColumnVertical) {\n      let prevRowExterior = new Dimensions2(node.State.SiblingsRowV.From, node.State.SiblingsRowV.To);\n      for (let row = 0; row < node.State.NumberOfSiblings; row++) {\n        let child = node.Children[row];\n        let rect = child.State;\n        let top = prevRowExterior.To + (row == 0 ? this.ParentChildSpacing : this.SiblingSpacing);\n        LayoutAlgorithm2.MoveTo(child.State, rect.Left, top);\n        child.State.BranchExterior = Rect2.from(child.State.Size, child.State.TopLeft);\n        let rowExterior = new Dimensions2(top, top + rect.Size.Height);\n        child = node.Children[row];\n        child.State.SiblingsRowV = rowExterior;\n        LayoutAlgorithm2.VerticalLayout(state, child);\n        let childBranchBottom = child.State.BranchExterior.Bottom;\n        prevRowExterior = new Dimensions2(rowExterior.From, Math.max(childBranchBottom, rowExterior.To));\n      }\n    }\n  }\n  ApplyHorizontalLayout(state, level) {\n    let node = level.BranchRoot;\n    for (let child of node.Children) {\n      LayoutAlgorithm2.HorizontalLayout(state, child);\n    }\n    if (node.ChildCount > 0) {\n      if (this.Orientation == StackOrientation2.SingleRowHorizontal) {\n        let width = node.Children[node.State.NumberOfSiblings - 1].State.Right - node.Children[0].State.Left;\n        node.State.Size = new Size2(Math.max(node.State.Size.Width, width), node.State.Size.Height);\n        let center = (node.Children[0].State.Left + node.Children[node.ChildCount - 1].State.Right) / 2;\n        let desiredCenter = node.State.CenterH;\n        let diff = desiredCenter - center;\n        LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n      } else if (this.Orientation == StackOrientation2.SingleColumnVertical) {\n        LayoutAlgorithm2.AlignHorizontalCenters(state, level, node.Children);\n        let center = node.Children[0].State.CenterH;\n        let desiredCenter = node.State.CenterH;\n        let diff = desiredCenter - center;\n        LayoutAlgorithm2.MoveChildrenOnly(state, level, diff);\n      }\n    }\n  }\n  RouteConnectors(state, node) {\n  }\n}\n","const peek = (array) => {\n  return array[array.length - 1];\n};\nexport {peek};\n","export default class Random {\n  constructor(seed) {\n  }\n  Next(range) {\n    return Math.floor(Math.random() * range);\n  }\n}\n","import Size2 from \"../core/Size\";\nimport Random2 from \"./Random\";\nexport default class TestDataGen {\n  GenerateDataItems(dataSource, count, percentAssistants) {\n    for (let item of this.GenerateRandomDataItems(count, percentAssistants)) {\n      dataSource.Items.set(item.Id, item);\n    }\n  }\n  GenerateRandomDataItems(itemCount, percentAssistants) {\n    if (itemCount < 0) {\n      throw new Error(\"ArgumentOutOfRangeException: \" + itemCount + \" - Count must be zero or positive\");\n    }\n    let random = new Random2(0);\n    let items = [];\n    for (let i = 0; i < itemCount; i++) {\n      items.push({\n        Id: i.toString(),\n        Date1: new Date(),\n        ParentId: null,\n        String1: null,\n        String2: null,\n        IsAssistant: false\n      });\n    }\n    let firstInLayer = 1;\n    let prevLayerSize = 1;\n    while (firstInLayer < itemCount) {\n      let layerSize = 15 + prevLayerSize + random.Next(prevLayerSize * 2);\n      for (let i = firstInLayer; i < firstInLayer + layerSize && i < itemCount; i++) {\n        let parentIndex = firstInLayer - 1 - random.Next(prevLayerSize);\n        items[i].ParentId = items[parentIndex].Id;\n      }\n      firstInLayer = firstInLayer + layerSize;\n      prevLayerSize = layerSize;\n    }\n    for (let i = 0; i < items.length / 2; i++) {\n      let from = random.Next(items.length);\n      let to = random.Next(items.length);\n      let temp = items[from];\n      items[from] = items[to];\n      items[to] = temp;\n    }\n    if (percentAssistants > 0) {\n      let assistantCount = Math.min(items.length, Math.round(Math.ceil(items.length * percentAssistants / 100)));\n      for (let i = 0; i < assistantCount; i++) {\n        items[random.Next(items.length)].IsAssistant = true;\n      }\n    }\n    return items;\n  }\n  static GenerateBoxSizes(boxContainer) {\n    const minWidth = 50;\n    const minHeight = 50;\n    const widthVariation = 50;\n    const heightVariation = 50;\n    let seed = 0;\n    let random = new Random2(seed);\n    for (let box of boxContainer.BoxesById.values()) {\n      if (!box.IsSpecial) {\n        box.Size = new Size2(minWidth + random.Next(widthVariation), minHeight + random.Next(heightVariation));\n      }\n    }\n  }\n}\n","export default class TestDataSource {\n  constructor() {\n    this.Items = new Map();\n    this.GetParentKeyFunc = (itemId) => this.GetParentKey(itemId);\n    this.GetDataItemFunc = (itemId) => this.GetDataItem(itemId);\n  }\n  GetParentKey(itemId) {\n    var _a;\n    return ((_a = this.Items.get(itemId)) == null ? void 0 : _a.ParentId) || null;\n  }\n  GetDataItem(itemId) {\n    const item = this.Items.get(itemId);\n    if (!item) {\n      throw Error(\"Could not find itemId\");\n    }\n    return item;\n  }\n  get AllDataItemIds() {\n    return [...this.Items.keys()].sort();\n  }\n}\n","import Diagram2 from \"../lib/core/Diagram\";\nimport BoxContainer2 from \"../lib/core/BoxContainer\";\nimport Operation2 from \"../lib/core/Operation\";\nimport LinearLayoutStrategy2 from \"../lib/core/LinearLayoutStrategy\";\nimport StackingLayoutStrategy2 from \"../lib/core/StackingLayoutStrategy\";\nimport MultiLineFishboneLayoutStrategy2 from \"../lib/core/MultiLineFishboneLayoutStrategy\";\nimport SingleColumnLayoutStrategy2 from \"../lib/core/SingleColumnLayoutStrategy\";\nimport BranchParentAlignment2 from \"../lib/core/BranchParentAlignment\";\nimport TestDataSource2 from \"../lib/test/TestDataSource\";\nimport TestDataGen2 from \"../lib/test/TestDataGen\";\nimport StackOrientation2 from \"../lib/core/StackOrientation\";\nimport LayoutState2 from \"../lib/core/LayoutState\";\nimport Size2 from \"../lib/core/Size\";\nimport LayoutAlgorithm2 from \"../lib/core/LayoutAlgorithm\";\nimport MultiLineHangerLayoutStrategy2 from \"../lib/core/MultiLineHangerLayoutStrategy\";\nimport FishboneAssistantsLayoutStrategy2 from \"../lib/core/FishboneAssistantsLayoutStrategy\";\nclass ChartApp {\n  constructor() {\n    this.suppressRootBox = false;\n    this.totalBoxCount = 20;\n    this.percentAssistants = 10;\n    this.onLayoutStateChanged = (state, args) => {\n      if (state.CurrentOperation === Operation2.PreprocessVisualTree) {\n        this.renderBoxes();\n      }\n    };\n    this.buildChart(true);\n  }\n  boxClick(boxId) {\n    const box = this.diagram.Boxes.BoxesById.get(boxId);\n    box.IsCollapsed = !box.IsCollapsed;\n    this.positionBoxes();\n  }\n  buildChart(initData) {\n    if (initData) {\n      this.initDiagram();\n    }\n    this.positionBoxes();\n  }\n  collapseAllBoxes(boxContainer, isCollapsed) {\n    for (const box of boxContainer.BoxesByDataId.values()) {\n      if (!box.IsSpecial) {\n        box.IsCollapsed = isCollapsed;\n      }\n    }\n  }\n  generateData() {\n    const count = this.totalBoxCount;\n    const percentAssistants = this.percentAssistants;\n    const dataSource = new TestDataSource2();\n    new TestDataGen2().GenerateDataItems(dataSource, count, percentAssistants);\n    if (this.suppressRootBox) {\n      dataSource.Items.delete(\"0\");\n      for (const dataItem of dataSource.Items.values()) {\n        if (dataItem.ParentId === \"0\") {\n          dataItem.ParentId = null;\n        }\n      }\n    }\n    return dataSource;\n  }\n  initDiagram() {\n    $(\"#myDiagramDiv\").html('<div id=\"myConnectors\" class=\"chartConnectorsPlane\"/>');\n    const dataSource = this.generateData();\n    this.dataSource = dataSource;\n    const boxContainer = new BoxContainer2(dataSource);\n    if ($(\"#CollapseAllOnRebuild\")[0].checked) {\n      this.collapseAllBoxes(boxContainer, true);\n    }\n    const diagram = this.diagram = new Diagram2();\n    diagram.Boxes = boxContainer;\n    const linearLayoutStrategy = new LinearLayoutStrategy2();\n    linearLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    diagram.LayoutSettings.LayoutStrategies.set(\"linear\", linearLayoutStrategy);\n    let multiLineHangerLayoutStrategy = new MultiLineHangerLayoutStrategy2();\n    multiLineHangerLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    multiLineHangerLayoutStrategy.MaxSiblingsPerRow = 2;\n    diagram.LayoutSettings.LayoutStrategies.set(\"hanger2\", multiLineHangerLayoutStrategy);\n    multiLineHangerLayoutStrategy = new MultiLineHangerLayoutStrategy2();\n    multiLineHangerLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    multiLineHangerLayoutStrategy.MaxSiblingsPerRow = 4;\n    diagram.LayoutSettings.LayoutStrategies.set(\"hanger4\", multiLineHangerLayoutStrategy);\n    let singleColumnLayoutStrategy = new SingleColumnLayoutStrategy2();\n    singleColumnLayoutStrategy.ParentAlignment = BranchParentAlignment2.Right;\n    diagram.LayoutSettings.LayoutStrategies.set(\"singleColumnRight\", singleColumnLayoutStrategy);\n    singleColumnLayoutStrategy = new SingleColumnLayoutStrategy2();\n    singleColumnLayoutStrategy.ParentAlignment = BranchParentAlignment2.Left;\n    diagram.LayoutSettings.LayoutStrategies.set(\"singleColumnLeft\", singleColumnLayoutStrategy);\n    let fishboneLayoutStrategy = new MultiLineFishboneLayoutStrategy2();\n    fishboneLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    fishboneLayoutStrategy.MaxGroups = 1;\n    diagram.LayoutSettings.LayoutStrategies.set(\"fishbone1\", fishboneLayoutStrategy);\n    fishboneLayoutStrategy = new MultiLineFishboneLayoutStrategy2();\n    fishboneLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    fishboneLayoutStrategy.MaxGroups = 2;\n    diagram.LayoutSettings.LayoutStrategies.set(\"fishbone2\", fishboneLayoutStrategy);\n    let hstackLayoutStrategy = new StackingLayoutStrategy2();\n    hstackLayoutStrategy.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    hstackLayoutStrategy.Orientation = StackOrientation2.SingleRowHorizontal;\n    hstackLayoutStrategy.ParentChildSpacing = 10;\n    diagram.LayoutSettings.LayoutStrategies.set(\"hstack\", hstackLayoutStrategy);\n    let vstackLayoutStrategy = new StackingLayoutStrategy2();\n    vstackLayoutStrategy.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    vstackLayoutStrategy.Orientation = StackOrientation2.SingleColumnVertical;\n    vstackLayoutStrategy.ParentChildSpacing = 10;\n    diagram.LayoutSettings.LayoutStrategies.set(\"vstack\", vstackLayoutStrategy);\n    vstackLayoutStrategy = new StackingLayoutStrategy2();\n    vstackLayoutStrategy.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    vstackLayoutStrategy.Orientation = StackOrientation2.SingleColumnVertical;\n    vstackLayoutStrategy.SiblingSpacing = 20;\n    diagram.LayoutSettings.LayoutStrategies.set(\"vstackMiddle\", vstackLayoutStrategy);\n    vstackLayoutStrategy = new StackingLayoutStrategy2();\n    vstackLayoutStrategy.ParentAlignment = BranchParentAlignment2.InvalidValue;\n    vstackLayoutStrategy.Orientation = StackOrientation2.SingleColumnVertical;\n    vstackLayoutStrategy.SiblingSpacing = 50;\n    diagram.LayoutSettings.LayoutStrategies.set(\"vstackTop\", vstackLayoutStrategy);\n    let assistantsLayoutStrategy = new FishboneAssistantsLayoutStrategy2();\n    assistantsLayoutStrategy.ParentAlignment = BranchParentAlignment2.Center;\n    diagram.LayoutSettings.LayoutStrategies.set(\"assistants\", assistantsLayoutStrategy);\n    diagram.LayoutSettings.DefaultLayoutStrategyId = \"fishbone1\";\n    diagram.LayoutSettings.DefaultAssistantLayoutStrategyId = \"assistants\";\n  }\n  getBoxLevel(boxContainer, box) {\n    let level = 0;\n    while (box.ParentId > 0) {\n      const value = boxContainer.BoxesById.get(box.ParentId);\n      if (!value) {\n        break;\n      }\n      box = value;\n      level++;\n    }\n    return level;\n  }\n  renderBoxes() {\n    let boxContainer = this.diagram.Boxes;\n    let dataSource = this.dataSource;\n    const elements = [];\n    const expanders = [];\n    let visitorFunc = (node) => {\n      let box = node.Element;\n      if (box.IsDataBound) {\n        let existing = $(\"#box\" + box.Id);\n        if (existing.length > 0) {\n          let exp = $(\"#exp\" + box.Id);\n          if (node.State.IsHidden) {\n            existing.hide();\n            if (exp.length > 0)\n              exp.hide();\n          } else {\n            existing.show();\n            if (exp.length > 0)\n              exp.show();\n          }\n          return true;\n        } else if (node.State.IsHidden) {\n          return true;\n        }\n        let level = this.getBoxLevel(boxContainer, box);\n        let dataItem = dataSource.GetDataItem(box.DataId);\n        const className = {\n          1: \"chartBoxTop\",\n          2: \"chartBoxMiddle\",\n          3: \"chartBoxLower\"\n        }[level] || \"chartBoxLowest\";\n        const position = {\n          1: \"Top\",\n          2: \"Middle\",\n          3: \"Lower\"\n        }[level] || level;\n        const element = document.createElement(\"div\");\n        element.className = className;\n        element.id = `box${box.Id}`;\n        element.style.position = \"absolute\";\n        element.style.width = \"150px\";\n        element.style.height = \"auto\";\n        element.innerText = `${position} - Box #${box.Id}, Data #${box.DataId}, Asst: ${box.IsAssistant}`;\n        element.addEventListener(\"click\", () => this.boxClick(box.Id));\n        elements.push(element);\n        if (node.ChildCount > 0 || node.AssistantsRoot != null) {\n          const expander = document.createElement(\"div\");\n          expander.id = `exp${box.Id}`;\n          expander.className = \"expander\";\n          expander.addEventListener(\"click\", () => this.boxClick(box.Id));\n          expanders.push(expander);\n        }\n        box.Size = this.getBoxElementSize(box.Id);\n      }\n      return true;\n    };\n    this.diagram.VisualTree.IterateParentFirst(visitorFunc);\n    const myDiagramDiv = document.querySelector(\"#myDiagramDiv\");\n    for (const expander of expanders) {\n      myDiagramDiv.appendChild(expander);\n    }\n    for (const element of elements) {\n      myDiagramDiv.appendChild(element);\n    }\n  }\n  getBranchOptimizerName(node) {\n    const selector = document.querySelector(\"input[name='SelectBranchOptimizer']:checked\");\n    const func = this[\"branchOptimizer\" + (selector == null ? void 0 : selector.value)] || this.branchOptimizerAllLinear;\n    return func(node);\n  }\n  branchOptimizerAllLinear(node) {\n    return node.IsAssistantRoot ? null : \"linear\";\n  }\n  branchOptimizerAllHanger2(node) {\n    return node.IsAssistantRoot ? null : \"hanger2\";\n  }\n  branchOptimizerAllHanger4(node) {\n    return node.IsAssistantRoot ? null : \"hanger4\";\n  }\n  branchOptimizerAllFishbone1(node) {\n    return node.IsAssistantRoot ? null : \"fishbone1\";\n  }\n  branchOptimizerAllFishbone2(node) {\n    return node.IsAssistantRoot ? null : \"fishbone2\";\n  }\n  branchOptimizerAllSingleColumnLeft(node) {\n    return node.IsAssistantRoot ? null : \"singleColumnRight\";\n  }\n  branchOptimizerAllSingleColumnRight(node) {\n    return node.IsAssistantRoot ? null : \"singleColumnLeft\";\n  }\n  branchOptimizerStackers(node) {\n    if (node.IsAssistantRoot) {\n      return null;\n    }\n    return node.Level === 0 ? \"vstackTop\" : node.Level === 1 ? \"vstackMiddle\" : \"hstack\";\n  }\n  branchOptimizerSmart(node) {\n    if (node.IsAssistantRoot) {\n      return null;\n    }\n    let childCount = node.ChildCount;\n    if (childCount <= 1) {\n      return \"vstack\";\n    }\n    let nonLeafChildren = 0;\n    for (let i = 0; i < childCount; i++) {\n      if (node.Children[i].ChildCount > 0) {\n        nonLeafChildren++;\n      }\n    }\n    if (nonLeafChildren <= 1) {\n      if (childCount <= 4) {\n        return \"vstack\";\n      }\n      if (childCount <= 8) {\n        return \"fishbone1\";\n      }\n      return \"fishbone2\";\n    }\n    return \"hanger4\";\n  }\n  boxSizeFunc(dataId) {\n    let boxId = this.diagram.Boxes.BoxesByDataId.get(dataId).Id;\n    return this.diagram.Boxes.BoxesById.get(boxId).Size;\n  }\n  getBoxElementSize(boxId) {\n    return new Size2(160, 50);\n  }\n  positionBoxes() {\n    $(\"#myConnectors\").html(\"\");\n    let boxContainer = this.diagram.Boxes;\n    let dataSource = this.dataSource;\n    let diagram = this.diagram;\n    let state = new LayoutState2(diagram);\n    state.OperationChanged = this.onLayoutStateChanged;\n    state.BoxSizeFunc = (dataId) => this.boxSizeFunc(dataId);\n    state.LayoutOptimizerFunc = (node) => this.getBranchOptimizerName(node);\n    console.log(\"positionBoxes\");\n    LayoutAlgorithm2.Apply(state);\n    const diagramBoundary = LayoutAlgorithm2.ComputeBranchVisualBoundingRect(diagram.VisualTree);\n    const myDiagramDiv = document.querySelector(\"#myDiagramDiv\");\n    if (myDiagramDiv == null) {\n      throw Error(\"Cannot find #myDiagramDiv\");\n    }\n    myDiagramDiv.style.width = `${diagramBoundary.Size.Width}px`;\n    myDiagramDiv.style.height = `${diagramBoundary.Size.Height}px`;\n    let offsetx = -diagramBoundary.Left;\n    let offsety = -diagramBoundary.Top;\n    const connectors = [];\n    let visitorFunc = function(node) {\n      if (node.State.IsHidden) {\n        return false;\n      }\n      let box = node.Element;\n      if (box.IsDataBound) {\n        const element = document.querySelector(`#box${box.Id}`);\n        if (element) {\n          let x = node.State.TopLeft.X + offsetx;\n          let y = node.State.TopLeft.Y + offsety;\n          element.style.left = `${x}px`;\n          element.style.top = `${y}px`;\n          element.style.width = `${node.State.Size.Width}px`;\n          element.style.height = `${node.State.Size.Height}px`;\n          if (node.ChildCount > 0 || node.AssistantsRoot != null) {\n            const exp = document.querySelector(\"#exp\" + box.Id);\n            if (exp) {\n              x = node.State.Right + offsetx - 15;\n              y = node.State.Bottom + offsety - 15;\n              exp.style.left = `${x}px`;\n              exp.style.top = `${y}px`;\n              if (box.IsCollapsed) {\n                exp.innerText = \"▼\";\n              } else {\n                exp.innerText = \"△\";\n              }\n            }\n          }\n        }\n      }\n      if (node.State.Connector != null) {\n        for (let ix = 0; ix < node.State.Connector.Segments.length; ix++) {\n          let edge = node.State.Connector.Segments[ix];\n          let edgeType;\n          let topLeft;\n          let width;\n          let height;\n          if (edge.From.Y === edge.To.Y) {\n            edgeType = \"chartHLine\";\n            height = 1;\n            if (edge.From.X < edge.To.X) {\n              topLeft = edge.From;\n              width = edge.To.X - edge.From.X;\n            } else {\n              topLeft = edge.To;\n              width = edge.From.X - edge.To.X;\n            }\n          } else {\n            edgeType = \"chartVLine\";\n            width = 1;\n            if (edge.From.Y < edge.To.Y) {\n              topLeft = edge.From;\n              height = edge.To.Y - edge.From.Y;\n            } else {\n              topLeft = edge.To;\n              height = edge.From.Y - edge.To.Y;\n            }\n          }\n          if (node.IsAssistantRoot) {\n            edgeType = edgeType + \"Dotted\";\n          }\n          const connector = document.createElement(\"div\");\n          connector.className = edgeType;\n          connector.style.top = `${topLeft.Y + offsety}px`;\n          connector.style.left = `${topLeft.X + offsetx}px`;\n          connector.style.width = `${width}px`;\n          connector.style.height = `${height}px`;\n          connectors.push(connector);\n        }\n      }\n      return true;\n    };\n    diagram.VisualTree.IterateParentFirst(visitorFunc);\n    const myConnectors = document.querySelector(\"#myConnectors\");\n    for (const connector of connectors) {\n      myConnectors.appendChild(connector);\n    }\n  }\n}\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"loaded!\");\n  if (window.chartApp) {\n    return;\n  }\n  const chartApp = window.chartApp = new ChartApp();\n  window.changedSuppressRootBox = function changedSuppressRootBox(cb) {\n    chartApp.suppressRootBox = cb.checked;\n    chartApp.buildChart(true);\n  };\n  window.clickCollapseAll = function clickCollapseAll(bt) {\n    chartApp.collapseAllBoxes(chartApp.diagram.Boxes, true);\n    chartApp.buildChart(false);\n  };\n  window.clickExpandAll = function clickExpandAll(bt) {\n    chartApp.collapseAllBoxes(chartApp.diagram.Boxes, false);\n    chartApp.buildChart(false);\n  };\n  window.clickOptimizer = function clickOptimizer(rd) {\n    chartApp.buildChart(false);\n  };\n  window.clickDataCounts = function clickDataCounts(rd) {\n    let value = rd.value;\n    if (value === \"small\") {\n      chartApp.totalBoxCount = 20;\n      chartApp.percentAssistants = 0;\n    } else if (value === \"small-a\") {\n      chartApp.totalBoxCount = 20;\n      chartApp.percentAssistants = 10;\n    } else if (value === \"large\") {\n      chartApp.totalBoxCount = 200;\n      chartApp.percentAssistants = 0;\n    } else if (value === \"large-a\") {\n      chartApp.totalBoxCount = 200;\n      chartApp.percentAssistants = 10;\n    } else if (value === \"huge-a\") {\n      chartApp.totalBoxCount = 1e3;\n      chartApp.percentAssistants = 5;\n    }\n    chartApp.buildChart(true);\n  };\n});\n"],"sourceRoot":""}