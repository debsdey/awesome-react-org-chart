import Rect from "./Rect";
import BoxTree from "./BoxTree";
import Node from "./Node";
import LayoutState from "./LayoutState";
import Operation from "./Operation";
import Point from "./Point";
import Box from "./box";
import LayoutStrategyBase from "./LayoutStrategyBase";
import LayoutLevel from "./LayoutLevel";
import Func from "./Func";
import Dimensions from "./Dimensions";
import NodeLayoutInfo from "./NodeLayoutInfo";
import Size from "./Size";
import { peek } from "./Utils";

export default class LayoutAlgorithm {
  /// <summary>
  /// Computes bounding rectangle in diagram space using only visible (non-autogenerated boxes).
  /// Useful for rendering the chart, as boxes frequently go into negative side horizontally, and have a special root box on top - all of those should not be accounted for.
  /// </summary>
  public static ComputeBranchVisualBoundingRect(visualTree: BoxTree): Rect {
    let result = new Rect(0, 0, 0, 0);
    let initialized = false;

    if (visualTree.Root == null) {
      throw Error("Root is null");
    }

    visualTree.Root.IterateParentFirst((node) => {
      var box = node.Element;

      if (!node.State.IsHidden && !box.IsSpecial) {
        if (node.State.Size == null) {
          throw Error("Size is null");
        }

        if (node.State.TopLeft == null) {
          throw Error("TopLeft is null");
        }
        if (initialized) {
          result = Rect.add(
            result,
            Rect.from(node.State.Size, node.State.TopLeft)
          );
        } else {
          initialized = true;

          result = Rect.from(node.State.Size, node.State.TopLeft);
        }
      }

      return !box.IsCollapsed;
    });

    return result;
  }

  /// <summary>
  /// Initializes <paramref name="state"/> and performs all layout operations.
  /// </summary>
  public static Apply(state: LayoutState): void {
    // verify the root
    if (state.Diagram.Boxes && state.Diagram.Boxes.SystemRoot == null) {
      throw new Error("SystemRoot is not initialized on the box container");
    }

    state.CurrentOperation = Operation.Preparing;

    var tree = BoxTree.Build(state);

    state.Diagram.VisualTree = tree;

    // verify the root: regardless of data items, there must be a system root box on top of everything
    // the corresponding node is not supposed to be rendered, it only serves as layout algorithm's starting point
    if (
      tree.Root == null ||
      (state.Diagram.Boxes &&
        tree.Root.Element.Id != state.Diagram.Boxes.SystemRoot?.Id)
    ) {
      throw new Error("SystemRoot is not on the top of the visual tree");
    }

    // set the tree and update visibility
    tree.UpdateHierarchyStats();
    state.AttachVisualTree(tree);

    // update visibility of boxes based on collapsed state
    tree.IterateParentFirst((node) => {
      node.State.IsHidden =
        node.ParentNode != null &&
        (node.ParentNode.State.IsHidden || node.ParentNode.Element.IsCollapsed);

      return true;
    });

    // In this phase, we will figure out layout strategy
    // and initialize layout state for each node.
    // Event listener may perform initial rendering /measuring of boxes when this event fires,
    // to determine box sizes and be ready to supply them via BoxSizeFunc delegate.
    state.CurrentOperation = Operation.PreprocessVisualTree;

    // initialize box sizes
    if (state.BoxSizeFunc != null) {
      // apply box sizes
      for (const box of [...state.Diagram.Boxes?.BoxesById.values()].filter(
        (x) => x.IsDataBound
      )) {
        box.Size = state.BoxSizeFunc(box.DataId);
      }
    }

    for (const box of state.Diagram.Boxes.BoxesById.values()) {
      this.AssertBoxSize(box);
    }

    // initialize layout state on each node
    tree.IterateParentFirst((node) => {
      LayoutAlgorithm.MoveTo(node.State, 0, 0);
      node.State.Size = node.Element.Size;
      node.State.BranchExterior = Rect.from(node.Element.Size, new Point(0, 0));

      return true;
    });

    this.PreprocessVisualTree(state, tree);
    tree.UpdateHierarchyStats();

    state.CurrentOperation = Operation.VerticalLayout;
    this.VerticalLayout(state, tree.Root);

    state.CurrentOperation = Operation.HorizontalLayout;
    this.HorizontalLayout(state, tree.Root);

    state.CurrentOperation = Operation.ConnectorsLayout;
    this.RouteConnectors(state, tree);

    state.CurrentOperation = Operation.Completed;
  }

  /// <summary>
  /// Ths function helps catch "undefined" values when operating in JavaScript-converted version of this code.
  /// Also, helps catch some bugs in C# version as well.
  /// They way it's implemented has direct impact on how JavaScript validation code looks like, so don't "optimize".
  /// </summary>
  private static AssertBoxSize(box: Box): void {
    if (box.Size.Width >= 0.0 && box.Size.Width <= 1000000000.0) {
      if (box.Size.Height >= 0.0 && box.Size.Width <= 1000000000.0) {
        return;
      }
    }

    throw new Error(
      `Box ${box.Id} has invalid size: ${box.Size.Width}x${box.Size.Height}`
    );
  }

  private static PreprocessVisualTree(
    state: LayoutState,
    visualTree: BoxTree
  ): void {
    const defaultStrategy = state.Diagram.LayoutSettings.RequireDefaultLayoutStrategy();
    const defaultAssistantsStrategy = state.Diagram.LayoutSettings.RequireDefaultAssistantLayoutStrategy();

    const regular: LayoutStrategyBase[] = [];
    regular.push(defaultStrategy);
    const assistants: LayoutStrategyBase[] = [];
    assistants.push(defaultAssistantsStrategy);

    visualTree.IterateParentFirst(
      (node) => {
        if (node.State.IsHidden) {
          return false;
        }

        let strategy: LayoutStrategyBase | undefined | null = null;

        if (state.LayoutOptimizerFunc != null) {
          var suggestedStrategyId = state.LayoutOptimizerFunc(node);
          if (suggestedStrategyId) {
            strategy = state.Diagram.LayoutSettings.LayoutStrategies.get(
              suggestedStrategyId
            );
          }
        }

        if (node.IsAssistantRoot) {
          if (strategy == null) {
            strategy =
              node.ParentNode?.Element.AssistantLayoutStrategyId != null
                ? state.Diagram.LayoutSettings.LayoutStrategies.get(
                    node.ParentNode.Element.AssistantLayoutStrategyId
                  )
                : peek(assistants);
          }

          if (strategy == null) {
            throw Error("Strategy is null. Maybe it allows null?");
          }

          assistants.push(strategy);
        } else {
          if (strategy == null) {
            strategy =
              node.Element.LayoutStrategyId != null
                ? state.Diagram.LayoutSettings.LayoutStrategies.get(
                    node.Element.LayoutStrategyId
                  )
                : peek(regular);
          }

          if (strategy == null) {
            throw Error("Strategy is null. Maybe it allows null?");
          }

          regular.push(strategy);

          if (!strategy.SupportsAssistants) {
            node.SuppressAssistants();
          }
        }

        // now let it pre-allocate special boxes etc
        node.State.EffectiveLayoutStrategy = strategy;
        node.State.RequireLayoutStrategy.PreProcessThisNode(state, node);

        return (
          (!node.Element.IsCollapsed && node.ChildCount > 0) ||
          node.AssistantsRoot != null
        );
      },
      (node) => {
        if (!node.State.IsHidden) {
          if (node.IsAssistantRoot) {
            assistants.pop();
          } else {
            regular.pop();
          }
        }
      }
    );
  }

  public static HorizontalLayout(state: LayoutState, branchRoot: Node): void {
    if (branchRoot.State.IsHidden) {
      throw new Error(
        `Branch root ${branchRoot.Element.Id} does not affect layout`
      );
    }

    let level = state.PushLayoutLevel(branchRoot);

    try {
      if (
        branchRoot.Level == 0 ||
        ((branchRoot.State.NumberOfSiblings > 0 ||
          branchRoot.AssistantsRoot != null) &&
          !branchRoot.Element.IsCollapsed)
      ) {
        branchRoot.State.RequireLayoutStrategy.ApplyHorizontalLayout(
          state,
          level
        );
      }
    } finally {
      state.PopLayoutLevel();
    }
  }

  /// <summary>
  /// Re-entrant layout algorithm.
  /// </summary>
  public static VerticalLayout(state: LayoutState, branchRoot: Node): void {
    if (branchRoot.State.IsHidden) {
      throw new Error(
        `Branch root ${branchRoot.Element.Id} does not affect layout`
      );
    }

    var level = state.PushLayoutLevel(branchRoot);
    try {
      if (
        branchRoot.Level == 0 ||
        ((branchRoot.State.NumberOfSiblings > 0 ||
          branchRoot.AssistantsRoot != null) &&
          !branchRoot.Element.IsCollapsed)
      ) {
        branchRoot.State.RequireLayoutStrategy.ApplyVerticalLayout(
          state,
          level
        );
      }
    } finally {
      state.PopLayoutLevel();
    }
  }

  private static RouteConnectors(state: LayoutState, visualTree: BoxTree) {
    visualTree.IterateParentFirst((node) => {
      if (
        node.Element.IsCollapsed ||
        (node.State.NumberOfSiblings == 0 && node.AssistantsRoot == null)
      ) {
        return false;
      }

      if (node.Level == 0) {
        return true;
      }

      if (!node.Element.IsSpecial || node.IsAssistantRoot) {
        node.State.RequireLayoutStrategy.RouteConnectors(state, node);
        return true;
      }

      return false;
    });
  }

  /// <summary>
  /// Moves a given branch horizontally, except its root box.
  /// Also updates branch exterior rects.
  /// Also updates branch boundary for the current <paramref name="layoutLevel"/>.
  /// </summary>
  public static MoveChildrenOnly(
    state: LayoutState,
    layoutLevel: LayoutLevel,
    offset: number
  ): void {
    const children = layoutLevel.BranchRoot.Children;
    if (children == null || children.length == 0) {
      throw new Error("Should never be invoked when children not set");
    }

    const action: Func<Node, boolean> = (node) => {
      if (!node.State.IsHidden) {
        try {
          node.State.TopLeft = node.State.TopLeft.MoveH(offset);
          node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);
        } catch (e) {
          // ignore
        }
      }

      return true;
    };

    for (const child of children) {
      child.IterateChildFirst(action);
    }

    layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);
    layoutLevel.BranchRoot.State.BranchExterior =
      layoutLevel.Boundary.BoundingRect;
  }

  /// <summary>
  /// Moves a given branch horizontally, except its root box.
  /// Also updates branch exterior rects.
  /// Unlike <see cref="MoveChildrenOnly"/> and <see cref="MoveBranch"/>, does NOT update the boundary.
  /// </summary>
  /// <remarks>DOES NOT update branch boundary! Must call <see cref="Boundary.ReloadFromBranch"/> after batch of updates is complete</remarks>
  private static MoveOneChild(
    state: LayoutState,
    root: Node,
    offset: number
  ): void {
    root.IterateChildFirst((node) => {
      if (!node.State.IsHidden) {
        node.State.TopLeft = node.State.TopLeft.MoveH(offset);
        node.State.BranchExterior = node.State.BranchExterior.MoveH(offset);
      }
      return true;
    });
  }

  /// <summary>
  /// Moves a given branch horizontally, including its root box.
  /// Also updates branch exterior rects.
  /// Also updates branch boundary for the current <paramref name="layoutLevel"/>.
  /// </summary>
  public static MoveBranch(
    state: LayoutState,
    layoutLevel: LayoutLevel,
    offset: number
  ): void {
    this.MoveOneChild(state, layoutLevel.BranchRoot, offset);
    layoutLevel.Boundary.ReloadFromBranch(layoutLevel.BranchRoot);
    layoutLevel.BranchRoot.State.BranchExterior =
      layoutLevel.Boundary.BoundingRect;
  }

  /// <summary>
  /// Vertically aligns a subset of child nodes, presumably located one above another.
  /// All children must belong to the current layout level's root.
  /// Returns leftmost and rightmost boundaries of all branches in the <paramref name="subset"/>, after alignment.
  /// </summary>
  public static AlignHorizontalCenters(
    state: LayoutState,
    level: LayoutLevel,
    subset: Node[]
  ): Dimensions {
    // compute the rightmost center in the column
    let center = Number.MIN_VALUE;

    for (const child of subset) {
      var c = child.State.CenterH;
      if (c > center) {
        center = c;
      }
    }

    // move those boxes in the column that are not aligned with the rightmost center
    let leftmost = Number.MAX_VALUE;
    let rightmost = Number.MIN_VALUE;
    for (const child of subset) {
      const frame = child.State;
      const c = frame.CenterH;

      if (c !== center) {
        const diff = center - c;
        this.MoveOneChild(state, child, diff);
      }

      leftmost = Math.min(leftmost, child.State.BranchExterior.Left);
      rightmost = Math.max(rightmost, child.State.BranchExterior.Right);
    }

    // update branch boundary
    level.Boundary.ReloadFromBranch(level.BranchRoot);

    return new Dimensions(leftmost, rightmost);
  }

  /// <summary>
  /// Copies vertical and horionztal measurement data from <paramref name="other"/> frame.
  /// Does not copy <see cref="Connector"/>.
  /// </summary>
  public static CopyExteriorFrom(
    state: NodeLayoutInfo,
    other: NodeLayoutInfo
  ): void {
    state.TopLeft = other.TopLeft;
    state.Size = other.Size;
    state.BranchExterior = other.BranchExterior;
    state.SiblingsRowV = other.SiblingsRowV;
  }

  /// <summary>
  /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
  /// </summary>
  public static IsMinValue(value: number): boolean {
    return value <= Number.MIN_VALUE + Number.EPSILON;
  }

  /// <summary>
  /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
  /// </summary>
  public static IsMaxValue(value: number): boolean {
    return value >= Number.MAX_VALUE - Number.EPSILON;
  }

  /// <summary>
  /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
  /// </summary>
  public static IsZero(value: number): boolean {
    return value <= Number.EPSILON && value >= -Number.EPSILON;
  }

  /// <summary>
  /// <c>true</c> if specified <paramref name="value"/> is equal to <see cref="double.MinValue"/>.
  /// </summary>
  public static IsEqual(value: number, other: number): boolean {
    return Math.abs(value - other) <= Number.EPSILON;
  }

  /// <summary>
  /// Changes <see cref="NodeLayoutInfo.TopLeft"/>.
  /// </summary>
  public static MoveTo(state: NodeLayoutInfo, x: number, y: number) {
    state.TopLeft = new Point(x, y);
  }

  /// <summary>
  /// Uitility for special boxes, spacers etc.
  /// Adjusts exterior and resets branch exterior to size.
  /// </summary>
  public static AdjustSpacer(
    state: NodeLayoutInfo,
    x: number,
    y: number,
    w: number,
    h: number
  ) {
    state.TopLeft = new Point(x, y);
    state.Size = new Size(w, h);
    state.BranchExterior = new Rect(x, y, w, h);
  }
}
